{"version":3,"sources":["../../../src/stringProcessing/getSentences.js"],"names":["text","blocks","block","split","newLineRegex","sentences","getSentencesFromBlockCached","isEmpty","newLines","RegExp","getSentencesFromBlock","sentenceTokenizer","SentenceTokenizer","createTokenizer","tokenizer","tokens","tokenize","length","getSentencesFromTokens"],"mappings":";;;;;;kBAwCe,UAAUA,IAAV,EAAiB;AAC/BA,QAAO,4CAAiBA,IAAjB,CAAP;AACA,KAAIC,SAAS,qBAAWD,IAAX,CAAb;;AAEA;AACAC,UAAS,uBAASA,MAAT,EAAiB,UAAUC,KAAV,EAAkB;AAC3C,SAAOA,MAAMC,KAAN,CAAaC,YAAb,CAAP;AACA,EAFQ,CAAT;;AAIA,OAAMC,YAAY,uBAASJ,MAAT,EAAiBK,2BAAjB,CAAlB;;AAEA,QAAO,sBAAQD,SAAR,EAAmB,sBAAQE,iBAAR,CAAnB,CAAP;AACA,C;;AAnDD;;AAOA;;AACA;;AACA;;;;;;AAEA;AAZA;AAaA,MAAMC,WAAW,YAAjB;;AAEA;;;AARA;AASA,MAAMJ,eAAe,IAAIK,MAAJ,CAAYD,QAAZ,CAArB;;AAEA;;;;;;AAMA,SAASE,qBAAT,CAAgCR,KAAhC,EAAwC;AACvC,OAAMS,oBAAoB,IAAIC,2BAAJ,EAA1B;;AADuC,6BAETD,kBAAkBE,eAAlB,EAFS;;AAAA,OAE/BC,SAF+B,yBAE/BA,SAF+B;AAAA,OAEpBC,MAFoB,yBAEpBA,MAFoB;;AAGvCJ,mBAAkBK,QAAlB,CAA4BF,SAA5B,EAAuCZ,KAAvC;;AAEA,QAAOa,OAAOE,MAAP,KAAkB,CAAlB,GAAsB,EAAtB,GAA2BN,kBAAkBO,sBAAlB,CAA0CH,MAA1C,CAAlC;AACA;;AAED,MAAMT,8BAA8B,uBAASI,qBAAT,CAApC;;AAEA","file":"getSentences.js","sourcesContent":["// Lodash imports.\nimport { filter } from \"lodash-es\";\nimport { flatMap } from \"lodash-es\";\nimport { isEmpty } from \"lodash-es\";\nimport { negate } from \"lodash-es\";\nimport { memoize } from \"lodash-es\";\n\n// Internal dependencies.\nimport { getBlocks } from \"../helpers/html.js\";\nimport { unifyNonBreakingSpace as unifyWhitespace } from \"../stringProcessing/unifyWhitespace.js\";\nimport SentenceTokenizer from \"./SentenceTokenizer\";\n\n// Character classes.\nconst newLines = \"\\n\\r|\\n|\\r\";\n\n// Regular expressions.\nconst newLineRegex = new RegExp( newLines );\n\n/**\n * Returns the sentences from a certain block.\n *\n * @param {string} block The HTML inside a HTML block.\n * @returns {Array<string>} The list of sentences in the block.\n */\nfunction getSentencesFromBlock( block ) {\n\tconst sentenceTokenizer = new SentenceTokenizer();\n\tconst { tokenizer, tokens } = sentenceTokenizer.createTokenizer();\n\tsentenceTokenizer.tokenize( tokenizer, block );\n\n\treturn tokens.length === 0 ? [] : sentenceTokenizer.getSentencesFromTokens( tokens );\n}\n\nconst getSentencesFromBlockCached = memoize( getSentencesFromBlock );\n\n/**\n * Returns sentences in a string.\n *\n * @param {String} text The string to count sentences in.\n * @returns {Array} Sentences found in the text.\n */\nexport default function( text ) {\n\ttext = unifyWhitespace( text );\n\tlet blocks = getBlocks( text );\n\n\t// Split each block on newlines.\n\tblocks = flatMap( blocks, function( block ) {\n\t\treturn block.split( newLineRegex );\n\t} );\n\n\tconst sentences = flatMap( blocks, getSentencesFromBlockCached );\n\n\treturn filter( sentences, negate( isEmpty ) );\n}\n"]}