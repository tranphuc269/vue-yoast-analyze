{"version":3,"sources":["../../../src/stringProcessing/determineProminentWords.js"],"names":["functionWordLists","specialCharacters","filterProminentWords","prominentWords","minimalNumberOfOccurrences","filter","combination","getOccurrences","getWord","replace","sortProminentWords","sort","wordA","wordB","difference","getStem","localeCompare","collapseProminentWordsOnStem","length","collapsedProminentWords","previousWord","ProminentWord","i","currentWord","setOccurrences","toLocaleLowerCase","setWord","push","retrieveFunctionWords","language","concat","retrieveAbbreviations","text","words","abbreviations","forEach","word","toLocaleUpperCase","computeProminentWords","morphologyData","functionWords","determineStem","uniqueContentWords","includes","trim","element","primeProminentWords","join","getProminentWords","computeProminentWordsMemoized","getProminentWordsFromPaperAttributes","attributes","wordsFromAttributes"],"mappings":"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","file":"determineProminentWords.js","sourcesContent":["import { get } from \"lodash-es\";\nimport { memoize } from \"lodash-es\";\nimport { uniq } from \"lodash-es\";\nimport retrieveStemmer from \"../helpers/retrieveStemmer\";\n\nimport getWords from \"../stringProcessing/getWords\";\nimport { normalizeSingle } from \"../stringProcessing/quotes\";\nimport ProminentWord from \"../values/ProminentWord\";\nimport functionWordListsFactory from \"../helpers/getFunctionWords\";\n\nconst functionWordLists = functionWordListsFactory();\nconst specialCharacters = /[1234567890‘’“”\"'.…?!:;,¿¡«»&*@#±^%$|~=+§`[\\](){}⟨⟩<>/\\\\–\\-\\u2014\\u00d7\\s]/g;\n\n/**\n * Returns only those prominent words that occur more than a certain number of times and do not consist of special characters.\n *\n * @param {ProminentWord[]} prominentWords A list of prominent words.\n * @param {int} [minimalNumberOfOccurrences] A minimal number of occurrences that is needed for a relevant prominentWord, default 2.\n *\n * @returns {ProminentWord[]} Only relevant word combinations.\n */\nfunction filterProminentWords( prominentWords, minimalNumberOfOccurrences = 2 ) {\n\tprominentWords = prominentWords.filter( function( combination ) {\n\t\treturn (\n\t\t\tcombination.getOccurrences() >= minimalNumberOfOccurrences &&\n\t\t\tcombination.getWord().replace( specialCharacters, \"\" ) !== \"\"\n\t\t);\n\t} );\n\treturn prominentWords;\n}\n\n/**\n * Sorts prominent words based on their number of occurrences and length.\n *\n * @param {ProminentWord[]} prominentWords The prominent words to sort.\n *\n * @returns {void}\n */\nfunction sortProminentWords( prominentWords ) {\n\tprominentWords.sort( function( wordA, wordB ) {\n\t\tconst difference = wordB.getOccurrences() - wordA.getOccurrences();\n\t\t// The combination with the highest number of occurrences comes first.\n\t\tif ( difference !== 0 ) {\n\t\t\treturn difference;\n\t\t}\n\n\t\t// In case of a tie on occurrence number, the alphabetically first combination comes first.\n\t\treturn wordA.getStem().localeCompare( wordB.getStem() );\n\t} );\n}\n\n/**\n * Collapses prominent words that have the same stem.\n *\n * @param {ProminentWord[]} prominentWords All prominentWords.\n *\n * @returns {ProminentWord[]} The original array with collapsed duplicates.\n */\nfunction collapseProminentWordsOnStem( prominentWords ) {\n\tif ( prominentWords.length === 0 ) {\n\t\treturn [];\n\t}\n\n\t// Sort the input array by stem\n\tprominentWords.sort( function( wordA, wordB ) {\n\t\treturn wordA.getStem().localeCompare( wordB.getStem() );\n\t} );\n\n\tconst collapsedProminentWords = [];\n\tlet previousWord = new ProminentWord(\n\t\tprominentWords[ 0 ].getWord(),\n\t\tprominentWords[ 0 ].getStem(),\n\t\tprominentWords[ 0 ].getOccurrences()\n\t);\n\n\tfor ( let i = 1; i < prominentWords.length; i++ ) {\n\t\tconst currentWord = new ProminentWord(\n\t\t\tprominentWords[ i ].getWord(),\n\t\t\tprominentWords[ i ].getStem(),\n\t\t\tprominentWords[ i ].getOccurrences()\n\t\t);\n\n\t\t/*\n\t\t * Compare the stem of the current word in the loop with the previously available stem.\n\t\t * If they equal, word combinations should be collapsed.\n\t\t * When collapsing, the numbers of occurrences get summed.\n\t\t * If the stem happens to equal the real word that occurred in the text, we can be sure it's ok to display it\n\t\t * to the customer. So, the stem reassigns the word.\n\t\t */\n\t\tif ( currentWord.getStem() ===  previousWord.getStem() ) {\n\t\t\tpreviousWord.setOccurrences( previousWord.getOccurrences() + currentWord.getOccurrences() );\n\n\t\t\tif ( currentWord.getWord() === previousWord.getStem() || currentWord.getWord().toLocaleLowerCase() === previousWord.getStem() ) {\n\t\t\t\tpreviousWord.setWord( currentWord.getWord() );\n\t\t\t}\n\t\t} else {\n\t\t\tcollapsedProminentWords.push( previousWord );\n\t\t\tpreviousWord = currentWord;\n\t\t}\n\t}\n\n\tcollapsedProminentWords.push( previousWord );\n\n\treturn collapsedProminentWords;\n}\n\n/**\n * Retrieves a function words list from the factory. Returns an empty array if the language does not have function words.\n *\n * @param {string} language The language to retrieve function words for.\n *\n * @returns {string[]} A list of function words for the language.\n */\nfunction retrieveFunctionWords( language ) {\n\treturn get( functionWordLists, language.concat( \".all\" ), [] );\n}\n\n/**\n * Retrieves a list of all abbreviations from the text. Returns an empty array if the input text is empty.\n *\n * @param {string} text A text.\n *\n * @returns {string[]} A list of abbreviations from the list.\n */\nfunction retrieveAbbreviations( text ) {\n\tconst words = getWords( normalizeSingle( text ) );\n\tconst abbreviations = [];\n\n\twords.forEach( function( word ) {\n\t\tif ( word.length > 1 && word.length < 5 && word === word.toLocaleUpperCase() ) {\n\t\t\tabbreviations.push( word.toLocaleLowerCase() );\n\t\t}\n\t} );\n\n\treturn uniq( abbreviations );\n}\n\n/**\n * Computes prominent words from an array of words. In order to do so, checks whether the word is included in the list of\n * function words and determines the number of occurrences for every word. Then checks if any two words have the same stem\n * and if so collapses over them.\n *\n * @param {string[]} words          The words to determine relevance for.\n * @param {string[]} abbreviations  Abbreviations that should not be stemmed.\n * @param {string} language         The paper's language.\n * @param {Object} morphologyData   The morphologyData available for the language of the paper.\n *\n * @returns {ProminentWord[]} All prominent words sorted and filtered for this text.\n */\nfunction computeProminentWords( words, abbreviations, language, morphologyData ) {\n\tconst functionWords = retrieveFunctionWords( language );\n\tconst determineStem = retrieveStemmer( language, morphologyData );\n\n\tif ( words.length === 0 ) {\n\t\treturn [];\n\t}\n\n\tconst uniqueContentWords = uniq( words.filter( word => ! functionWords.includes( word.trim() ) ) );\n\tconst prominentWords = [];\n\n\tuniqueContentWords.forEach( function( word ) {\n\t\tif ( abbreviations.includes( word ) ) {\n\t\t\tprominentWords.push( new ProminentWord(\n\t\t\t\tword.toLocaleUpperCase(),\n\t\t\t\tword,\n\t\t\t\twords.filter( element => element === word ).length\n\t\t\t) );\n\t\t} else {\n\t\t\tprominentWords.push( new ProminentWord(\n\t\t\t\tword,\n\t\t\t\tdetermineStem( word, morphologyData ),\n\t\t\t\twords.filter( element => element === word ).length\n\t\t\t) );\n\t\t}\n\t} );\n\n\treturn collapseProminentWordsOnStem( prominentWords );\n}\n\n/**\n * Caches prominent words depending on the currently available morphologyData and (separately) text words and language.\n * In this way, if the morphologyData remains the same in multiple calls of this function, the function\n * that collects actual prominent words only needs to check if the text words and language also remain the\n * same to return the cached result. The joining of words and language for this function is needed,\n * because by default memoize caches by the first key only, which in the current case would mean that the function would\n * return the cached forms if the text has not changed (without checking if language was changed).\n *\n * @param {Object|boolean}  morphologyData  The available morphology data.\n *\n * @returns {function} The function that collects prominent words for a given set of text words, language and morphologyData.\n */\nconst primeProminentWords = memoize( ( morphologyData ) => {\n\treturn memoize( ( words, abbreviations, language ) => {\n\t\treturn computeProminentWords( words, abbreviations, language, morphologyData );\n\t}, ( words, abbreviations, language ) => {\n\t\treturn words.join( \",\" ) + \",\" + abbreviations.join( \",\" ) + \",\" + language;\n\t} );\n} );\n\n\n/**\n * Gets prominent words from the paper text.\n *\n * @param {string}      text            The text to retrieve the prominent words from.\n * @param {string[]}    abbreviations   The abbreviations that occur in the text and attributes of the paper.\n * @param {string}      language        The paper's language.\n * @param {Object}      morphologyData  The morphologyData available for the language of the paper.\n *\n * @returns {ProminentWord[]} All prominent words sorted and filtered for this text.\n */\nfunction getProminentWords( text, abbreviations, language, morphologyData ) {\n\tif ( text === \"\" ) {\n\t\treturn [];\n\t}\n\n\tconst words = getWords( normalizeSingle( text ).toLocaleLowerCase() );\n\tconst computeProminentWordsMemoized = primeProminentWords( morphologyData );\n\n\treturn computeProminentWordsMemoized( words, abbreviations, language, morphologyData );\n}\n\n/**\n * Gets prominent words from keyphrase and synonyms, metadescription, title, and subheadings.\n *\n * @param {string[]}    attributes       The array with attributes to process.\n * @param {string[]}    abbreviations    The abbreviations that occur in the text and attributes of the paper.\n * @param {string}      language         The language of the paper.\n * @param {Object}      morphologyData   The morphologyData available for the language of the paper.\n *\n * @returns {ProminentWord[]} Prominent words from the paper attributes.\n */\nfunction getProminentWordsFromPaperAttributes( attributes, abbreviations, language, morphologyData ) {\n\tconst wordsFromAttributes = getWords( attributes.join( \" \" ).toLocaleLowerCase() );\n\n\treturn computeProminentWords( wordsFromAttributes, abbreviations, language, morphologyData );\n}\n\nexport {\n\tgetProminentWords,\n\tgetProminentWordsFromPaperAttributes,\n\tfilterProminentWords,\n\tsortProminentWords,\n\tcollapseProminentWordsOnStem,\n\tretrieveAbbreviations,\n};\n\nexport default {\n\tgetProminentWords,\n\tgetProminentWordsFromPaperAttributes,\n\tfilterProminentWords,\n\tsortProminentWords,\n\tcollapseProminentWordsOnStem,\n\tretrieveAbbreviations,\n};\n"]}