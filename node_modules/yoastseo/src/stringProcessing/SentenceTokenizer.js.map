{"version":3,"sources":["../../../src/stringProcessing/SentenceTokenizer.js"],"names":["fullStop","sentenceDelimiters","fullStopRegex","RegExp","sentenceDelimiterRegex","sentenceRegex","smallerThanContentRegex","htmlStartRegex","htmlEndRegex","blockStartRegex","blockEndRegex","sentenceEndRegex","SentenceTokenizer","isNumber","character","parseInt","isBreakTag","htmlTag","test","isQuotation","isPunctuation","removeDuplicateWhitespace","text","replace","isCapitalLetter","toLocaleLowerCase","isSmallerThanSign","getNextTwoCharacters","nextTokens","next","src","isLetterfromRTLLanguage","letter","ltrLetterRanges","some","ltrLetterRange","isValidSentenceBeginning","sentenceBeginning","isSentenceStart","token","type","isSentenceEnding","tokenizeSmallerThanContent","tokenSentences","currentSentence","localText","substring","tokenizerResult","createTokenizer","tokenize","tokenizer","localSentences","getSentencesFromTokens","tokens","push","length","shift","lastSentence","pop","forEach","sentence","match","addRule","onText","end","e","console","error","tokenizer2","tokenArray","trimSentences","nextSentenceStart","sliced","firstToken","lastToken","slice","i","hasNextSentence","nextCharacters","tokenizeResults","nextToken","previousToken","secondToNextToken","trim"],"mappings":";;;;;;AAAA;;AAIA;;;;AAEA;;;;AAEA;AACA,MAAMA,WAAW,GAAjB;AACA;;;;;AAKA,MAAMC,qBAAqB,uBAA3B;;AAEA,MAAMC,gBAAgB,IAAIC,MAAJ,CAAY,OAAOH,QAAP,GAAkB,IAA9B,CAAtB;AACA,MAAMI,yBAAyB,IAAID,MAAJ,CAAY,OAAOF,kBAAP,GAA4B,IAAxC,CAA/B;AACA,MAAMI,gBAAgB,IAAIF,MAAJ,CAAY,QAAQH,QAAR,GAAmBC,kBAAnB,GAAwC,kBAApD,CAAtB;AACA,MAAMK,0BAA0B,WAAhC;AACA,MAAMC,iBAAiB,uBAAvB;AACA,MAAMC,eAAe,wBAArB;;AAEA,MAAMC,kBAAkB,eAAxB;AACA,MAAMC,gBAAgB,gBAAtB;;AAEA,MAAMC,mBAAmB,IAAIR,MAAJ,CAAY,MAAMH,QAAN,GAAiBC,kBAAjB,GAAsC,IAAlD,CAAzB;;AAEA;;;AAGe,MAAMW,iBAAN,CAAwB;AACtC;;;;;;AAMAC,UAAUC,SAAV,EAAsB;AACrB,SAAO,CAAE,qBAAOC,SAAUD,SAAV,EAAqB,EAArB,CAAP,CAAT;AACA;;AAED;;;;;;AAMAE,YAAYC,OAAZ,EAAsB;AACrB,SAAO,OAAMC,IAAN,CAAYD,OAAZ;AAAP;AACA;;AAED;;;;;;AAMAE,aAAaL,SAAb,EAAyB;AACxBA,cAAY,uBAAiBA,SAAjB,CAAZ;;AAEA,SAAO,QAAQA,SAAR,IACN,SAASA,SADV;AAEA;;AAED;;;;;;;AAOAM,eAAeN,SAAf,EAA2B;AAC1B,SAAO,QAAQA,SAAR,IACN,QAAQA,SADT;AAEA;;AAED;;;;;;AAMAO,2BAA2BC,IAA3B,EAAkC;AACjC,SAAOA,KAAKC,OAAL,CAAc,KAAd,EAAqB,GAArB,CAAP;AACA;;AAED;;;;;;AAMAC,iBAAiBV,SAAjB,EAA6B;AAC5B,SAAOA,cAAcA,UAAUW,iBAAV,EAArB;AACA;;AAED;;;;;;;;;;AAUAC,mBAAmBZ,SAAnB,EAA+B;AAC9B,SAAOA,cAAc,GAArB;AACA;;AAED;;;;;;AAMAa,sBAAsBC,UAAtB,EAAmC;AAClC,MAAIC,OAAO,EAAX;;AAEA,MAAK,CAAE,2BAAaD,WAAY,CAAZ,CAAb,CAAP,EAAwC;AACvCC,WAAQD,WAAY,CAAZ,EAAgBE,GAAxB;AACA;;AAED,MAAK,CAAE,2BAAaF,WAAY,CAAZ,CAAb,CAAP,EAAwC;AACvCC,WAAQD,WAAY,CAAZ,EAAgBE,GAAxB;AACA;;AAEDD,SAAO,KAAKR,yBAAL,CAAgCQ,IAAhC,CAAP;;AAEA,SAAOA,IAAP;AACA;;AAED;;;;;;;;;AASAE,yBAAyBC,MAAzB,EAAkC;AACjC,QAAMC,kBAAkB;AACvB;AACA,uBAFuB;AAGvB;AACA,uBAJuB;AAKvB;AACA,kCANuB,CAAxB;;AASA,SACCA,gBAAgBC,IAAhB,CAAsBC,kBAAkBA,eAAejB,IAAf,CAAqBc,MAArB,CAAxC,CADD;AAGA;;AAED;;;;;;AAMAI,0BAA0BC,iBAA1B,EAA8C;AAC7C,SACC,KAAKb,eAAL,CAAsBa,iBAAtB,KACA,KAAKN,uBAAL,CAA8BM,iBAA9B,CADA,IAEA,KAAKxB,QAAL,CAAewB,iBAAf,CAFA,IAGA,KAAKlB,WAAL,CAAkBkB,iBAAlB,CAHA,IAIA,KAAKjB,aAAL,CAAoBiB,iBAApB,CAJA,IAKA,KAAKX,iBAAL,CAAwBW,iBAAxB,CAND;AAQA;;AAED;;;;;;AAMAC,iBAAiBC,KAAjB,EAAyB;AACxB,SAAS,CAAE,2BAAaA,KAAb,CAAF,KACR,iBAAiBA,MAAMC,IAAvB,IACA,eAAeD,MAAMC,IADrB,IAEA,kBAAkBD,MAAMC,IAHhB,CAAT;AAKA;;AAED;;;;;;;AAOAC,kBAAkBF,KAAlB,EAA0B;AACzB,SACC,CAAE,2BAAaA,KAAb,CAAF,KACEA,MAAMC,IAAN,KAAe,WAAf,IAA8BD,MAAMC,IAAN,KAAe,oBAD/C,CADD;AAIA;;AAED;;;;;;;;;AASAE,4BAA4BH,KAA5B,EAAmCI,cAAnC,EAAmDC,eAAnD,EAAqE;AACpE;;;;;AAKA,QAAMC,YAAYN,MAAMT,GAAN,CAAUgB,SAAV,CAAqB,CAArB,CAAlB;;AAEA;AACA,QAAMC,kBAAkB,KAAKC,eAAL,EAAxB;AACA,OAAKC,QAAL,CAAeF,gBAAgBG,SAA/B,EAA0CL,SAA1C;AACA,QAAMM,iBAAiB,KAAKC,sBAAL,CAA6BL,gBAAgBM,MAA7C,EAAqD,KAArD,CAAvB;;AAEAF,iBAAgB,CAAhB,IAAsB,2BAAaA,eAAgB,CAAhB,CAAb,IAAqC,GAArC,GAA2C,MAAMA,eAAgB,CAAhB,CAAvE;;AAEA;;;;;AAKA,MAAK,KAAKf,wBAAL,CAA+Be,eAAgB,CAAhB,CAA/B,CAAL,EAA4D;AAC3DR,kBAAeW,IAAf,CAAqBV,eAArB;AACAA,qBAAkB,EAAlB;AACA;AACDA,qBAAmBO,eAAgB,CAAhB,CAAnB;;AAEA,MAAKA,eAAeI,MAAf,GAAwB,CAA7B,EAAiC;AAChC;;;;AAIAZ,kBAAeW,IAAf,CAAqBV,eAArB;AACAA,qBAAkB,EAAlB;;AAEA;AACAO,kBAAeK,KAAf;AACA;AACA,SAAMC,eAAeN,eAAeO,GAAf,EAArB;;AAEA;AACAP,kBAAeQ,OAAf,CAAwBC,YAAY;AACnCjB,mBAAeW,IAAf,CAAqBM,QAArB;AACA,IAFD;;AAIA;AACA,OAAKH,aAAaI,KAAb,CAAoBlD,gBAApB,CAAL,EAA8C;AAC7C;AACAgC,mBAAeW,IAAf,CAAqBG,YAArB;AACA,IAHD,MAGO;AACN;AACAb,sBAAkBa,YAAlB;AACA;AACD;AACD,SAAO;AACNd,iBADM;AAENC;AAFM,GAAP;AAIA;;AAED;;;;;AAKAI,mBAAkB;AACjB,QAAMK,SAAS,EAAf;AACA,QAAMH,YAAY,oBAAM,UAAUX,KAAV,EAAkB;AACzCc,UAAOC,IAAP,CAAaf,KAAb;AACA,GAFiB,CAAlB;;AAIAW,YAAUY,OAAV,CAAmB5D,aAAnB,EAAkC,WAAlC;AACAgD,YAAUY,OAAV,CAAmBxD,uBAAnB,EAA4C,2BAA5C;AACA4C,YAAUY,OAAV,CAAmBvD,cAAnB,EAAmC,YAAnC;AACA2C,YAAUY,OAAV,CAAmBtD,YAAnB,EAAiC,UAAjC;AACA0C,YAAUY,OAAV,CAAmBrD,eAAnB,EAAoC,aAApC;AACAyC,YAAUY,OAAV,CAAmBpD,aAAnB,EAAkC,WAAlC;AACAwC,YAAUY,OAAV,CAAmB1D,sBAAnB,EAA2C,oBAA3C;AACA8C,YAAUY,OAAV,CAAmBzD,aAAnB,EAAkC,UAAlC;;AAEA,SAAO;AACN6C,YADM;AAENG;AAFM,GAAP;AAIA;;AAED;;;;;;;AAOAJ,UAAUC,SAAV,EAAqB5B,IAArB,EAA4B;AAC3B4B,YAAUa,MAAV,CAAkBzC,IAAlB;;AAEA,MAAI;AACH4B,aAAUc,GAAV;AACA,GAFD,CAEE,OAAQC,CAAR,EAAY;AACbC,WAAQC,KAAR,CAAe,sBAAf,EAAuCF,CAAvC,EAA0CA,EAAEG,UAA5C;AACA;AACD;;AAED;;;;;;;;AAQAhB,wBAAwBiB,UAAxB,EAAoCC,gBAAgB,IAApD,EAA2D;AAC1D,MAAI3B,iBAAiB,EAArB;AAAA,MAAyBC,kBAAkB,EAA3C;AAAA,MAA+C2B,iBAA/C;AAAA,MAAkEC,MAAlE;;AAEA;AACA,KAAG;AACFA,YAAS,KAAT;AACA,SAAMC,aAAaJ,WAAY,CAAZ,CAAnB;AACA,SAAMK,YAAYL,WAAYA,WAAWd,MAAX,GAAoB,CAAhC,CAAlB;;AAEA,OAAKkB,cAAcC,SAAd,IAA2BD,WAAWjC,IAAX,KAAoB,YAA/C,IAA+DkC,UAAUlC,IAAV,KAAmB,UAAvF,EAAoG;AACnG6B,iBAAaA,WAAWM,KAAX,CAAkB,CAAlB,EAAqBN,WAAWd,MAAX,GAAoB,CAAzC,CAAb;;AAEAiB,aAAS,IAAT;AACA;AACD,GAVD,QAUUA,UAAUH,WAAWd,MAAX,GAAoB,CAVxC;;AAYAc,aAAWV,OAAX,CAAoB,CAAEpB,KAAF,EAASqC,CAAT,KAAgB;AACnC,OAAIC,eAAJ,EAAqBC,cAArB,EAAqCC,eAArC;AACA,SAAMC,YAAYX,WAAYO,IAAI,CAAhB,CAAlB;AACA,SAAMK,gBAAgBZ,WAAYO,IAAI,CAAhB,CAAtB;AACA,SAAMM,oBAAoBb,WAAYO,IAAI,CAAhB,CAA1B;;AAEA,WAASrC,MAAMC,IAAf;AACC,SAAK,YAAL;AACA,SAAK,UAAL;AACC,SAAK,KAAKxB,UAAL,CAAiBuB,MAAMT,GAAvB,CAAL,EAAoC;AACnCa,qBAAeW,IAAf,CAAqBV,eAArB;AACAA,wBAAkB,EAAlB;AACA,MAHD,MAGO;AACNA,yBAAmBL,MAAMT,GAAzB;AACA;AACD;;AAED,SAAK,2BAAL;AACCiD,uBAAkB,KAAKrC,0BAAL,CAAiCH,KAAjC,EAAwCI,cAAxC,EAAwDC,eAAxD,CAAlB;AACAD,sBAAiBoC,gBAAgBpC,cAAjC;AACAC,uBAAkBmC,gBAAgBnC,eAAlC;AACA;AACD,SAAK,UAAL;AACCA,wBAAmBL,MAAMT,GAAzB;AACA;AACD,SAAK,oBAAL;AACCc,wBAAmBL,MAAMT,GAAzB;;AAEA,SAAK,CAAE,2BAAakD,SAAb,CAAF,IAA8B,gBAAgBA,UAAUxC,IAAxD,IAAgE,yBAAyBwC,UAAUxC,IAAxG,EAA+G;AAC9GG,qBAAeW,IAAf,CAAqBV,eAArB;AACAA,wBAAkB,EAAlB;AACA;AACD;;AAED,SAAK,WAAL;AACCA,wBAAmBL,MAAMT,GAAzB;;AAEAgD,sBAAiB,KAAKnD,oBAAL,CAA2B,CAAEqD,SAAF,EAAaE,iBAAb,CAA3B,CAAjB;;AAEA;AACAL,uBAAkBC,eAAevB,MAAf,IAAyB,CAA3C;AACAgB,yBAAoBM,kBAAkBC,eAAgB,CAAhB,CAAlB,GAAwC,EAA5D;AACA;AACA,SAAKD,mBAAmB,KAAKhE,QAAL,CAAeiE,eAAgB,CAAhB,CAAf,CAAxB,EAA+D;AAC9D;AACA;AACD;AACA,SAAOD,mBAAmB,KAAKzC,wBAAL,CAA+BmC,iBAA/B,CAArB,IAA6E,KAAKjC,eAAL,CAAsB0C,SAAtB,CAAlF,EAAsH;AACrHrC,qBAAeW,IAAf,CAAqBV,eAArB;AACAA,wBAAkB,EAAlB;AACA;AACD;;AAED,SAAK,aAAL;AACCA,wBAAmBL,MAAMT,GAAzB;AACA;;AAED,SAAK,WAAL;AACCc,wBAAmBL,MAAMT,GAAzB;;AAEAgD,sBAAiB,KAAKnD,oBAAL,CAA2B,CAAEqD,SAAF,EAAaE,iBAAb,CAA3B,CAAjB;;AAEA;AACAL,uBAAkBC,eAAevB,MAAf,IAAyB,CAA3C;AACAgB,yBAAoBM,kBAAkBC,eAAgB,CAAhB,CAAlB,GAAwC,EAA5D;;AAEA;;;;AAIA,SACCD,mBAAmB,KAAKhE,QAAL,CAAeiE,eAAgB,CAAhB,CAAf,CAAnB,IACE,KAAKrC,gBAAL,CAAuBwC,aAAvB,KACC,EAAI,KAAK7C,wBAAL,CAA+BmC,iBAA/B,KAAsD,KAAKjC,eAAL,CAAsB0C,SAAtB,CAA1D,CAHJ,EAIE;AACD;AACA;;AAED;;;;AAIA,SACC,KAAKvC,gBAAL,CAAuBwC,aAAvB,MACE,KAAK7C,wBAAL,CAA+BmC,iBAA/B,KAAsD,KAAKjC,eAAL,CAAsB0C,SAAtB,CADxD,CADD,EAGE;AACDrC,qBAAeW,IAAf,CAAqBV,eAArB;AACAA,wBAAkB,EAAlB;AACA;AACD;AAnFF;AAqFA,GA3FD;;AA6FA,MAAK,OAAOA,eAAZ,EAA8B;AAC7BD,kBAAeW,IAAf,CAAqBV,eAArB;AACA;;AAED,MAAK0B,aAAL,EAAqB;AACpB3B,oBAAiB,mBAAKA,cAAL,EAAqB,UAAUiB,QAAV,EAAqB;AAC1D,WAAOA,SAASuB,IAAT,EAAP;AACA,IAFgB,CAAjB;AAGA;;AAED,SAAOxC,cAAP;AACA;AA1ZqC;kBAAlB/B,iB","file":"SentenceTokenizer.js","sourcesContent":["import { map } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { isNaN } from \"lodash-es\";\n\nimport core from \"tokenizer2/core\";\n\nimport { normalize as normalizeQuotes } from \"../stringProcessing/quotes.js\";\n\n// All characters that indicate a sentence delimiter.\nconst fullStop = \".\";\n/*\n * \\u2026 - ellipsis\n * \\u06D4 - Urdu full stop\n * \\u061f - Arabic question mark\n */\nconst sentenceDelimiters = \"?!;\\u2026\\u06d4\\u061f\";\n\nconst fullStopRegex = new RegExp( \"^[\" + fullStop + \"]$\" );\nconst sentenceDelimiterRegex = new RegExp( \"^[\" + sentenceDelimiters + \"]$\" );\nconst sentenceRegex = new RegExp( \"^[^\" + fullStop + sentenceDelimiters + \"<\\\\(\\\\)\\\\[\\\\]]+$\" );\nconst smallerThanContentRegex = /^<[^><]*$/;\nconst htmlStartRegex = /^<([^>\\s/]+)[^>]*>$/mi;\nconst htmlEndRegex = /^<\\/([^>\\s]+)[^>]*>$/mi;\n\nconst blockStartRegex = /^\\s*[[({]\\s*$/;\nconst blockEndRegex = /^\\s*[\\])}]\\s*$/;\n\nconst sentenceEndRegex = new RegExp( \"[\" + fullStop + sentenceDelimiters + \"]$\" );\n\n/**\n * Class for tokenizing a (html) text into sentences.\n */\nexport default class SentenceTokenizer {\n\t/**\n\t * Returns whether or not a certain character is a number.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisNumber( character ) {\n\t\treturn ! isNaN( parseInt( character, 10 ) );\n\t}\n\n\t/**\n\t * Returns whether or not a given HTML tag is a break tag.\n\t *\n\t * @param {string} htmlTag The HTML tag to check.\n\t * @returns {boolean} Whether or not the given HTML tag is a break tag.\n\t */\n\tisBreakTag( htmlTag ) {\n\t\treturn /<br/.test( htmlTag );\n\t}\n\n\t/**\n\t * Returns whether or not a given character is quotation mark.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a quotation mark.\n\t */\n\tisQuotation( character ) {\n\t\tcharacter = normalizeQuotes( character );\n\n\t\treturn \"'\" === character ||\n\t\t\t\"\\\"\" === character;\n\t}\n\n\t/**\n\t * Returns whether or not a given character is a punctuation mark that can be at the beginning\n\t * of a sentence, like ¿ and ¡ used in Spanish.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the given character is a punctuation mark.\n\t */\n\tisPunctuation( character ) {\n\t\treturn \"¿\" === character ||\n\t\t\t\"¡\" === character;\n\t}\n\n\t/**\n\t * Removes duplicate whitespace from a given text.\n\t *\n\t * @param {string} text The text with duplicate whitespace.\n\t * @returns {string} The text without duplicate whitespace.\n\t */\n\tremoveDuplicateWhitespace( text ) {\n\t\treturn text.replace( /\\s+/, \" \" );\n\t}\n\n\t/**\n\t * Returns whether or not a certain character is a capital letter.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisCapitalLetter( character ) {\n\t\treturn character !== character.toLocaleLowerCase();\n\t}\n\n\t/**\n\t * Checks whether the given character is a smaller than sign.\n\t *\n\t * This function is used to make sure that tokenizing the content after\n\t * the smaller than sign works as expected.\n\t * E.g. 'A sentence. < Hello world!' = ['A sentence.', '< Hello world!'].\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether the character is a smaller than sign ('<') or not.\n\t */\n\tisSmallerThanSign( character ) {\n\t\treturn character === \"<\";\n\t}\n\n\t/**\n\t * Retrieves the next two characters from an array with the two next tokens.\n\t *\n\t * @param {Array} nextTokens The two next tokens. Might be undefined.\n\t * @returns {string} The next two characters.\n\t */\n\tgetNextTwoCharacters( nextTokens ) {\n\t\tlet next = \"\";\n\n\t\tif ( ! isUndefined( nextTokens[ 0 ] ) ) {\n\t\t\tnext += nextTokens[ 0 ].src;\n\t\t}\n\n\t\tif ( ! isUndefined( nextTokens[ 1 ] ) ) {\n\t\t\tnext += nextTokens[ 1 ].src;\n\t\t}\n\n\t\tnext = this.removeDuplicateWhitespace( next );\n\n\t\treturn next;\n\t}\n\n\t/**\n\t * Checks whether a character is from a language that's written from right to left.\n\t * These languages don't have capital letter forms. Therefore any letter from these languages is a\n\t * potential sentence beginning.\n\t *\n\t * @param {string} letter The letter to check.\n\t *\n\t * @returns {boolean} Whether the letter is from an LTR language.\n\t */\n\tisLetterfromRTLLanguage( letter ) {\n\t\tconst ltrLetterRanges = [\n\t\t\t// Hebrew characters.\n\t\t\t/^[\\u0590-\\u05fe]+$/i,\n\t\t\t// Arabic characters (used for Arabic, Farsi, Urdu).\n\t\t\t/^[\\u0600-\\u06FF]+$/i,\n\t\t\t// Additional Farsi characters.\n\t\t\t/^[\\uFB8A\\u067E\\u0686\\u06AF]+$/i,\n\t\t];\n\n\t\treturn (\n\t\t\tltrLetterRanges.some( ltrLetterRange => ltrLetterRange.test( letter ) )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the sentenceBeginning beginning is a valid beginning.\n\t *\n\t * @param {string} sentenceBeginning The beginning of the sentence to validate.\n\t * @returns {boolean} Returns true if it is a valid beginning, false if it is not.\n\t */\n\tisValidSentenceBeginning( sentenceBeginning ) {\n\t\treturn (\n\t\t\tthis.isCapitalLetter( sentenceBeginning ) ||\n\t\t\tthis.isLetterfromRTLLanguage( sentenceBeginning ) ||\n\t\t\tthis.isNumber( sentenceBeginning ) ||\n\t\t\tthis.isQuotation( sentenceBeginning ) ||\n\t\t\tthis.isPunctuation( sentenceBeginning ) ||\n\t\t\tthis.isSmallerThanSign( sentenceBeginning )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the token is a valid sentence start.\n\t *\n\t * @param {Object} token The token to validate.\n\t * @returns {boolean} Returns true if the token is valid sentence start, false if it is not.\n\t */\n\tisSentenceStart( token ) {\n\t\treturn ( ! isUndefined( token ) && (\n\t\t\t\"html-start\" === token.type ||\n\t\t\t\"html-end\" === token.type ||\n\t\t\t\"block-start\" === token.type\n\t\t) );\n\t}\n\n\t/**\n\t * Checks if the token is a valid sentence ending. A valid sentence ending is either a full stop or another\n\t * delimiter such as \"?\", \"!\", etc.\n\t *\n\t * @param {Object} token The token to validate.\n\t * @returns {boolean} Returns true if the token is valid sentence ending, false if it is not.\n\t */\n\tisSentenceEnding( token ) {\n\t\treturn (\n\t\t\t! isUndefined( token ) &&\n\t\t\t( token.type === \"full-stop\" || token.type === \"sentence-delimiter\" )\n\t\t);\n\t}\n\n\t/**\n\t * Tokens that represent a '<', followed by content until it enters another '<' or '>'\n\t * gets another pass by the tokenizer.\n\t *\n\t * @param {Object} token A token of type 'smaller-than-sign-content'.\n\t * @param {string[]} tokenSentences The current array of found sentences. Sentences may get added by this method.\n\t * @param {string} currentSentence The current sentence. Sentence parts may get appended by this method.\n\t * @returns {{tokenSentences, currentSentence}} The found sentences and the current sentence, appended when necessary.\n\t */\n\ttokenizeSmallerThanContent( token, tokenSentences, currentSentence ) {\n\t\t/*\n\t\t\tRemove the '<' from the text, to avoid matching this rule\n\t\t\trecursively again and again.\n\t\t\tWe add it again later on.\n\t\t*/\n\t\tconst localText = token.src.substring( 1 );\n\n\t\t// Tokenize the current smaller-than-content token without the first '<'.\n\t\tconst tokenizerResult = this.createTokenizer();\n\t\tthis.tokenize( tokenizerResult.tokenizer, localText );\n\t\tconst localSentences = this.getSentencesFromTokens( tokenizerResult.tokens, false );\n\n\t\tlocalSentences[ 0 ] = isUndefined( localSentences[ 0 ] ) ? \"<\" : \"<\" + localSentences[ 0 ];\n\n\t\t/*\n\t\t * When the first sentence has a valid sentence beginning.\n\t\t * Add the currently build sentence to the sentences.\n\t\t * Start building the next sentence.\n\t\t */\n\t\tif ( this.isValidSentenceBeginning( localSentences[ 0 ] ) ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\t\t}\n\t\tcurrentSentence += localSentences[ 0 ];\n\n\t\tif ( localSentences.length > 1 ) {\n\t\t\t/*\n\t\t\t\tThere is a new sentence after the first,\n\t\t\t\tadd and reset the current sentence.\n\t\t\t */\n\t\t\ttokenSentences.push( currentSentence );\n\t\t\tcurrentSentence = \"\";\n\n\t\t\t// Remove the first sentence (we do not need to add it again).\n\t\t\tlocalSentences.shift();\n\t\t\t// Last sentence gets special treatment.\n\t\t\tconst lastSentence = localSentences.pop();\n\n\t\t\t// Add the remaining found sentences.\n\t\t\tlocalSentences.forEach( sentence => {\n\t\t\t\ttokenSentences.push( sentence );\n\t\t\t} );\n\n\t\t\t// Check if the last sentence has a valid sentence ending.\n\t\t\tif ( lastSentence.match( sentenceEndRegex ) ) {\n\t\t\t\t// If so, add it as a sentence.\n\t\t\t\ttokenSentences.push( lastSentence );\n\t\t\t} else {\n\t\t\t\t// If not, start making a new one.\n\t\t\t\tcurrentSentence = lastSentence;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttokenSentences,\n\t\t\tcurrentSentence,\n\t\t};\n\t}\n\n\t/**\n\t * Creates a tokenizer.\n\t *\n\t * @returns {Object} The tokenizer and the tokens.\n\t */\n\tcreateTokenizer() {\n\t\tconst tokens = [];\n\t\tconst tokenizer = core( function( token ) {\n\t\t\ttokens.push( token );\n\t\t} );\n\n\t\ttokenizer.addRule( fullStopRegex, \"full-stop\" );\n\t\ttokenizer.addRule( smallerThanContentRegex, \"smaller-than-sign-content\" );\n\t\ttokenizer.addRule( htmlStartRegex, \"html-start\" );\n\t\ttokenizer.addRule( htmlEndRegex, \"html-end\" );\n\t\ttokenizer.addRule( blockStartRegex, \"block-start\" );\n\t\ttokenizer.addRule( blockEndRegex, \"block-end\" );\n\t\ttokenizer.addRule( sentenceDelimiterRegex, \"sentence-delimiter\" );\n\t\ttokenizer.addRule( sentenceRegex, \"sentence\" );\n\n\t\treturn {\n\t\t\ttokenizer,\n\t\t\ttokens,\n\t\t};\n\t}\n\n\t/**\n\t * Tokenizes the given text using the given tokenizer.\n\t *\n\t * @param {Object} tokenizer The tokenizer to use.\n\t * @param {string} text The text to tokenize.\n\t * @returns {void}\n\t */\n\ttokenize( tokenizer, text ) {\n\t\ttokenizer.onText( text );\n\n\t\ttry {\n\t\t\ttokenizer.end();\n\t\t} catch ( e ) {\n\t\t\tconsole.error( \"Tokenizer end error:\", e, e.tokenizer2 );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of sentences for a given array of tokens, assumes that the text has already been split into blocks.\n\t *\n\t * @param {Object[]} tokenArray The tokens from the sentence tokenizer.\n\t * @param {boolean} [trimSentences=true] Whether to trim the sentences at the end or not.\n\t *\n\t * @returns {string[]} A list of sentences.\n\t */\n\tgetSentencesFromTokens( tokenArray, trimSentences = true ) {\n\t\tlet tokenSentences = [], currentSentence = \"\", nextSentenceStart, sliced;\n\n\t\t// Drop the first and last HTML tag if both are present.\n\t\tdo {\n\t\t\tsliced = false;\n\t\t\tconst firstToken = tokenArray[ 0 ];\n\t\t\tconst lastToken = tokenArray[ tokenArray.length - 1 ];\n\n\t\t\tif ( firstToken && lastToken && firstToken.type === \"html-start\" && lastToken.type === \"html-end\" ) {\n\t\t\t\ttokenArray = tokenArray.slice( 1, tokenArray.length - 1 );\n\n\t\t\t\tsliced = true;\n\t\t\t}\n\t\t} while ( sliced && tokenArray.length > 1 );\n\n\t\ttokenArray.forEach( ( token, i ) => {\n\t\t\tlet hasNextSentence, nextCharacters, tokenizeResults;\n\t\t\tconst nextToken = tokenArray[ i + 1 ];\n\t\t\tconst previousToken = tokenArray[ i - 1 ];\n\t\t\tconst secondToNextToken = tokenArray[ i + 2 ];\n\n\t\t\tswitch ( token.type ) {\n\t\t\t\tcase \"html-start\":\n\t\t\t\tcase \"html-end\":\n\t\t\t\t\tif ( this.isBreakTag( token.src ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"smaller-than-sign-content\":\n\t\t\t\t\ttokenizeResults = this.tokenizeSmallerThanContent( token, tokenSentences, currentSentence );\n\t\t\t\t\ttokenSentences = tokenizeResults.tokenSentences;\n\t\t\t\t\tcurrentSentence = tokenizeResults.currentSentence;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sentence-delimiter\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tif ( ! isUndefined( nextToken ) && \"block-end\" !== nextToken.type && \"sentence-delimiter\" !== nextToken.type ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"full-stop\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 1 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Only split on sentence delimiters when the next sentence looks like the start of a sentence.\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-start\":\n\t\t\t\t\tcurrentSentence += token.src;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-end\":\n\t\t\t\t\tcurrentSentence += token.src;\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 0 ] : \"\";\n\n\t\t\t\t\t/* Don't split if:\n\t\t\t\t\t * - The next character is a number. For example: IPv4-numbers.\n\t\t\t\t\t * - The block end is preceded by a valid sentence ending, but not followed by a valid sentence beginning.\n\t\t\t\t\t */\n\t\t\t\t\tif (\n\t\t\t\t\t\thasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ||\n\t\t\t\t\t\t( this.isSentenceEnding( previousToken ) &&\n\t\t\t\t\t\t\t( ! ( this.isValidSentenceBeginning( nextSentenceStart ) || this.isSentenceStart( nextToken ) ) ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Split if:\n\t\t\t\t\t * - The block end is preceded by a sentence ending and followed by a valid sentence beginning.\n\t\t\t\t\t */\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isSentenceEnding( previousToken ) &&\n\t\t\t\t\t\t( this.isValidSentenceBeginning( nextSentenceStart ) || this.isSentenceStart( nextToken ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\n\t\tif ( \"\" !== currentSentence ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t}\n\n\t\tif ( trimSentences ) {\n\t\t\ttokenSentences = map( tokenSentences, function( sentence ) {\n\t\t\t\treturn sentence.trim();\n\t\t\t} );\n\t\t}\n\n\t\treturn tokenSentences;\n\t}\n}\n"]}