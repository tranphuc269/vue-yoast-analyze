{"version":3,"sources":["../../../../src/morphology/russian/stem.js"],"names":["stem","isVowel","char","morphologyData","externalStemmer","vowels","includes","findRvRegion","word","rv","state","wordLength","length","i","prevChar","substring","removeEndings","regex","region","prefix","substr","ending","currentRegex","Array","isArray","RegExp","test","replace","removeInflectionalSuffixes","removeDerivationalNounSuffix","regexDerivationalNounSuffix","removeGerundSuffixes","regexPerfectiveGerunds1","regexPerfectiveGerunds2","removeReflexiveSuffixes","regexReflexives","regexAdjective","removeParticipleSuffixes","regexParticiple","removeAdjectiveSuffixes","removeVerbalSuffixes","regexVerb1","regexVerb2","removeNounSuffixes","regexNoun","checkWordInFullFormExceptions","exceptions","paradigm","canonicalizeStems","wordsWithMultipleStems","multipleStems","find","stems","doNotStemSuffix","fullFormException","exceptionStemsWithFullForms","removeIEnding","regexI","endsWith","doubleN","removeSuperlativeSuffixes","regexSuperlative","removeSoftSignEnding","regexSoftSign","canonicalizedStem","stemsThatBelongToOneWord"],"mappings":"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","file":"stem.js","sourcesContent":["/**\n * MIT License\n *\n * Copyright (c) 2016 Alexander Kiryukhin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * https://github.com/neonxp/Stemmer/blob/master/src/NXP/Stemmer.php\n */\n\n/**\n * Checks if the input character is a Russian vowel.\n *\n * @param {string} char             The character to be checked.\n * @param {Object} morphologyData   The Russian morphology data.\n *\n * @returns {boolean} Whether the input character is a Russian vowel.\n */\nconst isVowel = function( char, morphologyData ) {\n\treturn morphologyData.externalStemmer.vowels.includes( char );\n};\n\n/**\n * Determines the RV region of the word.\n *\n * @param {string} word             The word checked.\n * @param {Object} morphologyData   The Russian morphology data.\n\n *\n * @returns {int} The RV region index.\n */\nconst findRvRegion = function( word, morphologyData ) {\n\tlet rv = 0;\n\tlet state = 0;\n\tconst wordLength = word.length;\n\n\tfor ( let i = 1; i < wordLength; i++ ) {\n\t\tconst prevChar = word.substring( i - 1, i );\n\t\tconst char = word.substring( i, i + 1 );\n\t\tswitch ( state ) {\n\t\t\tcase 0:\n\t\t\t\tif ( isVowel( char, morphologyData ) ) {\n\t\t\t\t\trv = i + 1;\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ( isVowel( prevChar, morphologyData ) && isVowel( char, morphologyData ) ) {\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif ( isVowel( prevChar, morphologyData ) && isVowel( char, morphologyData ) ) {\n\t\t\t\t\treturn rv;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rv;\n};\n\n/**\n * Removes the endings from the word.\n *\n * @param {string}          word\tThe word to check.\n * @param {string|string[]} regex\tThe regex or a pair of regexes to match.\n * @param {int}             region\tThe word region\n *\n * @returns {string|null}\tThe word if the stemming rule could be applied or null otherwise.\n */\nconst removeEndings = function( word, regex, region ) {\n\tconst prefix = word.substr( 0, region );\n\tconst ending = word.substr( prefix.length );\n\n\tlet currentRegex;\n\n\tif ( Array.isArray( regex ) ) {\n\t\tcurrentRegex = new RegExp( regex[ 0 ], \"i\" );\n\n\t\tif ( currentRegex.test( ending ) ) {\n\t\t\tword = prefix + ending.replace( currentRegex, \"\" );\n\t\t\treturn word;\n\t\t}\n\n\t\tcurrentRegex = new RegExp( regex[ 1 ], \"i\" );\n\t} else {\n\t\tcurrentRegex = new RegExp( regex, \"i\" );\n\t}\n\n\tif ( currentRegex.test( ending ) ) {\n\t\tword = prefix + ending.replace( currentRegex, \"\" );\n\t\treturn word;\n\t}\n\n\treturn null;\n};\n\n/**\n * Removes inflectional suffixes from the word.\n *\n * @param {string} word             The word to check.\n * @param {Object} morphologyData   The Russian morphology data.\n * @param {int}    rv               The word rv region.\n *\n * @returns {string}\tThe word after inflectional suffixes were removed.\n */\nconst removeInflectionalSuffixes = function( word, morphologyData, rv ) {\n\tconst removeDerivationalNounSuffix = removeEndings( word, morphologyData.externalStemmer.regexDerivationalNounSuffix, rv );\n\tif ( removeDerivationalNounSuffix ) {\n\t\treturn removeDerivationalNounSuffix;\n\t}\n\t// Try to find a PERFECTIVE GERUND ending. If it exists, remove it and finalize the step.\n\tconst removeGerundSuffixes = removeEndings(\n\t\tword,\n\t\t[ morphologyData.externalStemmer.regexPerfectiveGerunds1, morphologyData.externalStemmer.regexPerfectiveGerunds2 ],\n\t\trv\n\t);\n\n\tif ( removeGerundSuffixes ) {\n\t\tword = removeGerundSuffixes;\n\t} else {\n\t\t// If there is no PERFECTIVE GERUND ending then try removing a REFLEXIVE ending.\n\t\tconst removeReflexiveSuffixes = removeEndings( word, morphologyData.externalStemmer.regexReflexives, rv );\n\n\t\tif ( removeReflexiveSuffixes ) {\n\t\t\tword = removeReflexiveSuffixes;\n\t\t}\n\n\t\t// Try to remove following endings (in this order): ADJECTIVAL, VERB, NOUN. If one of them is found the step is finalized.\n\t\tconst regexAdjective = morphologyData.externalStemmer.regexAdjective;\n\t\tconst removeParticipleSuffixes = removeEndings( word, morphologyData.externalStemmer.regexParticiple + regexAdjective, rv );\n\t\tconst removeAdjectiveSuffixes = removeEndings( word, regexAdjective, rv );\n\n\t\tif ( removeParticipleSuffixes ) {\n\t\t\tword = removeParticipleSuffixes;\n\t\t} else if ( removeAdjectiveSuffixes ) {\n\t\t\tword = removeAdjectiveSuffixes;\n\t\t} else {\n\t\t\tconst removeVerbalSuffixes = removeEndings(\n\t\t\t\tword,\n\t\t\t\t[ morphologyData.externalStemmer.regexVerb1, morphologyData.externalStemmer.regexVerb2 ],\n\t\t\t\trv\n\t\t\t);\n\t\t\tif ( removeVerbalSuffixes ) {\n\t\t\t\tword = removeVerbalSuffixes;\n\t\t\t} else {\n\t\t\t\tconst removeNounSuffixes = removeEndings( word, morphologyData.externalStemmer.regexNoun, rv );\n\t\t\t\tif ( removeNounSuffixes ) {\n\t\t\t\t\tword = removeNounSuffixes;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn word;\n};\n\n/**\n * Checks whether a word is in the full-form exception list and if so returns the canonical stem.\n *\n * @param {string} word\t      The word to be checked.\n * @param {Object} exceptions The list of full-form exceptions to be checked in.\n *\n * @returns {null|string} The canonical stem or null if nothing was found.\n */\nconst checkWordInFullFormExceptions = function( word, exceptions ) {\n\tfor ( const paradigm of exceptions ) {\n\t\tif ( paradigm[ 1 ].includes( word ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Returns a canonical stem for verbs with multiple stems.\n *\n * @param {string}  word                    The word to canonicalize.\n * @param {Array}   wordsWithMultipleStems  An array of arrays of stems belonging to one word.\n *\n * @returns {string} A canonical stem or the original word.\n */\nconst canonicalizeStems = function( word, wordsWithMultipleStems ) {\n\tconst multipleStems = wordsWithMultipleStems.find( stems => stems.includes( word ) );\n\n\tif ( multipleStems ) {\n\t\treturn multipleStems[ 0 ];\n\t}\n\n\treturn word;\n};\n\n/**\n * Stems russian words.\n *\n * @param {string} word             The word to stem.\n * @param {Object} morphologyData   The Russian morphology data.\n *\n * @returns {string}\tThe stemmed word.\n */\nexport default function stem( word, morphologyData ) {\n\t// Check if word is in the doNotStemSuffix exception list.\n\tif ( morphologyData.doNotStemSuffix.includes( word ) ) {\n\t\treturn word;\n\t}\n\n\t// Check if the word is on the list of exceptions for which we listed all forms and the stem.\n\tconst fullFormException = checkWordInFullFormExceptions( word, morphologyData.exceptionStemsWithFullForms );\n\tif ( fullFormException ) {\n\t\treturn fullFormException;\n\t}\n\n\tconst rv = findRvRegion( word, morphologyData );\n\n\t// Step 1: Remove inflectional suffixes if they are present in the word.\n\tword = removeInflectionalSuffixes( word, morphologyData, rv );\n\n\t// Step 2: If the word ends in \"и\", remove it.\n\tconst removeIEnding = removeEndings( word, morphologyData.externalStemmer.regexI, rv );\n\tif ( removeIEnding ) {\n\t\tword = removeIEnding;\n\t}\n\n\t// Step 3: There can be one of three options:\n\t// 1. If the word ends in нн, remove the last letter.\n\tif ( word.endsWith( morphologyData.externalStemmer.doubleN ) ) {\n\t\tword = word.substr( 0, word.length - 1 );\n\t}\n\n\t// 2. If the word ends in a SUPERLATIVE ending, remove it and then again the last letter if the word ends in \"нн\".\n\tconst removeSuperlativeSuffixes = removeEndings( word, morphologyData.externalStemmer.regexSuperlative, rv );\n\tif ( removeSuperlativeSuffixes ) {\n\t\tword = removeSuperlativeSuffixes;\n\t}\n\n\t// 3. If the word ends in \"ь\", remove it.\n\tconst removeSoftSignEnding = removeEndings( word, morphologyData.externalStemmer.regexSoftSign, rv );\n\tif ( removeSoftSignEnding ) {\n\t\tword = removeSoftSignEnding;\n\t}\n\n\t// Check if the stem is on the list of stems that belong to one word and if so, return the canonical stem.\n\tconst canonicalizedStem = canonicalizeStems( word, morphologyData.stemsThatBelongToOneWord );\n\tif ( canonicalizedStem ) {\n\t\treturn canonicalizedStem;\n\t}\n\n\treturn word;\n}\n"]}