{"version":3,"sources":["../../../../src/morphology/english/determineStem.js"],"names":["findShortestAndAlphabeticallyFirst","determineIrregularStem","determineIrregularVerbStem","determineRegularStem","determineStem","array","strings","result","pop","forEach","str","lengthDifference","length","localeCompare","word","irregulars","i","paradigm","j","verbMorphology","paradigmIfIrregularVerb","irregularVerbs","regexVerb","verbPrefixes","morphologyData","verbs","baseIfPluralNoun","nouns","regexNoun","singularize","ingFormToInfinitive","regexAdjective","adjectives","baseIfIcally","icallyToBase","possibleRegularBases","baseIfVerb","infinitive","push","stopAdjectives","baseIfAdjective","base","nounMorphology","baseIfPossessive","possessiveToBase","stem","irregular","irregularNouns","irregularAdjectives"],"mappings":";;;;;QAgBgBA,kC,GAAAA,kC;QA2BAC,sB,GAAAA,sB;QAsBAC,0B,GAAAA,0B;QAgBAC,oB,GAAAA,oB;QA4CAC,a,GAAAA,a;;AA7HhB;;AAGA;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;;;;;AAQO,SAASJ,kCAAT,CAA6CK,KAA7C,EAAqD;AAC3D,OAAMC,UAAU,uBAASD,KAAT,CAAhB;AACA,KAAIE,SAASD,QAAQE,GAAR,EAAb;;AAEAF,SAAQG,OAAR,CAAiBC,OAAO;AACvB,QAAMC,mBAAmBD,IAAIE,MAAJ,GAAaL,OAAOK,MAA7C;AACA,MAAKD,qBAAqB,CAA1B,EAA8B;AAC7B,OAAKD,IAAIG,aAAJ,CAAmBN,MAAnB,IAA8B,CAAnC,EAAuC;AACtCA,aAASG,GAAT;AACA;AACD,GAJD,MAIO,IAAKC,mBAAmB,CAAxB,EAA4B;AAClCJ,YAASG,GAAT;AACA;AACD,EATD;;AAWA,QAAOH,MAAP;AACA;;AAED;;;;;;;;;AASO,SAASN,sBAAT,CAAiCa,IAAjC,EAAuCC,UAAvC,EAAoD;AAC1D,MAAM,IAAIC,IAAI,CAAd,EAAiBA,IAAID,WAAWH,MAAhC,EAAwCI,GAAxC,EAA8C;AAC7C,QAAMC,WAAWF,WAAYC,CAAZ,CAAjB;AACA,OAAM,IAAIE,IAAI,CAAd,EAAiBA,IAAID,SAASL,MAA9B,EAAsCM,GAAtC,EAA4C;AAC3C,OAAKD,SAAUC,CAAV,MAAkBJ,IAAvB,EAA8B;AAC7B,WAAOG,SAAU,CAAV,CAAP;AACA;AACD;AACD;AACD,QAAO,IAAP;AACA;;AAED;;;;;;;;;;AAUO,SAASf,0BAAT,CAAqCY,IAArC,EAA2CK,cAA3C,EAA4D;AAClE,OAAMC,0BAA0B,kCAA0BN,IAA1B,EAAgCK,eAAeE,cAA/C,EAA+DF,eAAeG,SAAf,CAAyBC,YAAxF,CAAhC;AACA,KAAK,CAAE,2BAAaH,uBAAb,CAAP,EAAgD;AAC/C,SAAOA,wBAAyB,CAAzB,CAAP;AACA;AACD,QAAO,IAAP;AACA;;AAED;;;;;;;;AAQO,SAASjB,oBAAT,CAA+BW,IAA/B,EAAqCU,cAArC,EAAsD;AAC5D;AACA,OAAMF,YAAYE,eAAeC,KAAf,CAAqBH,SAAvC;AACA,OAAMI,mBAAmB,0CAAuBZ,IAAvB,EAA6B,6CAA+BU,eAAeG,KAAf,CAAqBC,SAArB,CAA+BC,WAA9D,CAA7B,CAAzB;AACA,KAAK,CAAE,2BAAaH,gBAAb,CAAP,EAAyC;AACxC;AACA,MAAK,8BAAaA,gBAAb,CAAL,EAAuC;AACtC,UAAO,0CAAuBA,gBAAvB,EAAyC,6CAA+BJ,UAAUQ,mBAAzC,CAAzC,CAAP;AACA;AACD,SAAOJ,gBAAP;AACA;;AAED;AACA,OAAMK,iBAAiBP,eAAeQ,UAAf,CAA0BD,cAAjD;AACA,OAAME,eAAe,0CAAuBnB,IAAvB,EAA6B,6CAA+BiB,eAAeG,YAA9C,CAA7B,CAArB;AACA,KAAK,CAAE,2BAAaD,YAAb,CAAP,EAAqC;AACpC,SAAOA,YAAP;AACA;;AAED;AACA,OAAME,uBAAuB,EAA7B;;AAEA;AACA,OAAMC,aAAa,gCAAetB,IAAf,EAAqBQ,SAArB,EAAiCe,UAApD;;AAEAF,sBAAqBG,IAArB,CAA2BF,UAA3B;;AAEA;AACA,OAAMG,iBAAiBf,eAAeQ,UAAf,CAA0BO,cAAjD;;AAEA,OAAMC,kBAAkB,gCAAkB1B,IAAlB,EAAwBiB,cAAxB,EAAwCQ,cAAxC,EAAyDE,IAAjF;AACAN,sBAAqBG,IAArB,CAA2BE,eAA3B;;AAEA,QAAOxC,mCAAoCmC,oBAApC,CAAP;AACA;;AAED;;;;;;;;AAQO,SAAS/B,aAAT,CAAwBU,IAAxB,EAA8BU,cAA9B,EAA+C;AACrD,OAAMkB,iBAAiBlB,eAAeG,KAAtC;;AAEA,OAAMgB,mBAAmB,0CAAuB7B,IAAvB,EAA6B,6CAA+B4B,eAAed,SAAf,CAAyBgB,gBAAxD,CAA7B,CAAzB;;AAEA,KAAIC,IAAJ,EAAUC,SAAV;;AAEA;AACA,KAAK,2BAAaH,gBAAb,CAAL,EAAuC;AACtCE,SAAO/B,IAAP;AACA;AACAgC,cAAY7C,uBAAwBa,IAAxB,EAA8B4B,eAAeK,cAA7C,KACX9C,uBAAwBa,IAAxB,EAA8BU,eAAeQ,UAAf,CAA0BgB,mBAAxD,CADW,IAEX9C,2BAA4BY,IAA5B,EAAkCU,eAAeC,KAAjD,CAFD;AAGA,EAND,MAMO;AACNoB,SAAOF,gBAAP;AACA;AACAG,cAAY7C,uBAAwB0C,gBAAxB,EAA0CD,eAAeK,cAAzD,CAAZ;AACA;;AAED,KAAKD,SAAL,EAAiB;AAChB;AACA,SAAOA,SAAP;AACA;;AAED;AACA,QAAO3C,qBAAsB0C,IAAtB,EAA4BrB,cAA5B,CAAP;AACA","file":"determineStem.js","sourcesContent":["import { isUndefined } from \"lodash-es\";\nimport { flatten } from \"lodash-es\";\n\nimport { buildOneFormFromRegex } from \"../morphoHelpers/buildFormRule\";\nimport createRulesFromMorphologyData from  \"../morphoHelpers/createRulesFromMorphologyData.js\";\nimport getAdjectiveStem from \"./getAdjectiveStem\";\nimport { getInfinitive, checkIrregulars as getIrregularVerbParadigm, endsWithIng } from \"./getVerbStem.js\";\n\n/**\n * Gets the shortest of the alphabetically ordered strings from an array.\n *\n * @param {string[]} array  The array of strings.\n *\n * @returns {string|undefined}  The shortest of the alphabetically ordered strings from the input array;\n *                              undefined if the input array is empty.\n */\nexport function findShortestAndAlphabeticallyFirst( array ) {\n\tconst strings = flatten( array );\n\tlet result = strings.pop();\n\n\tstrings.forEach( str => {\n\t\tconst lengthDifference = str.length - result.length;\n\t\tif ( lengthDifference === 0 ) {\n\t\t\tif ( str.localeCompare( result ) < 0 ) {\n\t\t\t\tresult = str;\n\t\t\t}\n\t\t} else if ( lengthDifference < 0 ) {\n\t\t\tresult = str;\n\t\t}\n\t} );\n\n\treturn result;\n}\n\n/**\n * Checks if the input word occurs in the list of exceptions and if so returns the first form of the paradigm, which is\n * always the base.\n *\n * @param {string} word                 The word for which to determine its base.\n * @param {Array}  irregulars           An array of irregular nouns and adjectives.\n *\n * @returns {string|null} The base form of the irregular word; null if no irregular stem was found.\n */\nexport function determineIrregularStem( word, irregulars ) {\n\tfor ( let i = 0; i < irregulars.length; i++ ) {\n\t\tconst paradigm = irregulars[ i ];\n\t\tfor ( let j = 0; j < paradigm.length; j++ ) {\n\t\t\tif ( paradigm[ j ] === word ) {\n\t\t\t\treturn paradigm[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Checks if the input word occurs in the list of exception verbs and if so returns the first form\n * of the paradigm, which is always the base. Contrary to nouns and adjectives, irregular verbs can have different prefixes\n * which are not included in the list of exceptions and have to be processed separately.\n *\n * @param {string}    word            The word for which to determine its base.\n * @param {Object}    verbMorphology  Regexes and irregulars for verb morphology, False if verb rules should not be applied.\n *\n * @returns {string|null} The base form of the irregular word; null if no irregular stem was found.\n */\nexport function determineIrregularVerbStem( word, verbMorphology ) {\n\tconst paradigmIfIrregularVerb = getIrregularVerbParadigm( word, verbMorphology.irregularVerbs, verbMorphology.regexVerb.verbPrefixes );\n\tif ( ! isUndefined( paradigmIfIrregularVerb ) ) {\n\t\treturn paradigmIfIrregularVerb[ 0 ];\n\t}\n\treturn null;\n}\n\n/**\n * Gets possible stems as a regular noun, adjective and verb.\n *\n * @param {string} word              The word for which to determine its base.\n * @param {Object} morphologyData    The morphology data for the language.\n *\n * @returns {string} The shortest and the alphabetically-first of possible noun-like, verb-like and adjective-like bases.\n */\nexport function determineRegularStem( word, morphologyData ) {\n\t// Try to singularize as a noun.\n\tconst regexVerb = morphologyData.verbs.regexVerb;\n\tconst baseIfPluralNoun = buildOneFormFromRegex( word, createRulesFromMorphologyData( morphologyData.nouns.regexNoun.singularize ) );\n\tif ( ! isUndefined( baseIfPluralNoun ) ) {\n\t\t// Bring ing-nouns to base forms (\"blessings\" -> \"bless\").\n\t\tif ( endsWithIng( baseIfPluralNoun ) ) {\n\t\t\treturn buildOneFormFromRegex( baseIfPluralNoun, createRulesFromMorphologyData( regexVerb.ingFormToInfinitive ) );\n\t\t}\n\t\treturn baseIfPluralNoun;\n\t}\n\n\t// Check if the word ends with \"ic\", \"ical\" or \"ically\". Return the \"ical\" form for consistency.\n\tconst regexAdjective = morphologyData.adjectives.regexAdjective;\n\tconst baseIfIcally = buildOneFormFromRegex( word, createRulesFromMorphologyData( regexAdjective.icallyToBase ) );\n\tif ( ! isUndefined( baseIfIcally ) ) {\n\t\treturn baseIfIcally;\n\t}\n\n\t// No more quick guesses, we have to determine a verbal infinitive and an adjectival base.\n\tconst possibleRegularBases = [];\n\n\t// Verbal infinitive.\n\tconst baseIfVerb = getInfinitive( word, regexVerb ).infinitive;\n\n\tpossibleRegularBases.push( baseIfVerb );\n\n\t// Adjectival base.\n\tconst stopAdjectives = morphologyData.adjectives.stopAdjectives;\n\n\tconst baseIfAdjective = getAdjectiveStem( word, regexAdjective, stopAdjectives ).base;\n\tpossibleRegularBases.push( baseIfAdjective );\n\n\treturn findShortestAndAlphabeticallyFirst( possibleRegularBases );\n}\n\n/**\n * Returns the stem of the input word using the morphologyData (language-specific).\n *\n * @param   {string} word           The word to get the stem for.\n * @param   {Object} morphologyData The available morphology data per language (false if unavailable).\n *\n * @returns {string} Stemmed (or base) form of the word.\n */\nexport function determineStem( word, morphologyData ) {\n\tconst nounMorphology = morphologyData.nouns;\n\n\tconst baseIfPossessive = buildOneFormFromRegex( word, createRulesFromMorphologyData( nounMorphology.regexNoun.possessiveToBase ) );\n\n\tlet stem, irregular;\n\n\t// Determine if this is an irregular noun, adjective or verb.\n\tif ( isUndefined( baseIfPossessive ) ) {\n\t\tstem = word;\n\t\t// Word can be a noun, adjective or verb.\n\t\tirregular = determineIrregularStem( word, nounMorphology.irregularNouns ) ||\n\t\t\tdetermineIrregularStem( word, morphologyData.adjectives.irregularAdjectives ) ||\n\t\t\tdetermineIrregularVerbStem( word, morphologyData.verbs );\n\t} else {\n\t\tstem = baseIfPossessive;\n\t\t// The word is a possessive, it can only be a noun or an ing-noun;\n\t\tirregular = determineIrregularStem( baseIfPossessive, nounMorphology.irregularNouns );\n\t}\n\n\tif ( irregular ) {\n\t\t// Found the stem of an irregular word! Return it.\n\t\treturn irregular;\n\t}\n\n\t// Treat the word as a regular noun, adjective or verb.\n\treturn determineRegularStem( stem, morphologyData );\n}\n"]}