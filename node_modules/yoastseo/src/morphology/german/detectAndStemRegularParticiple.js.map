{"version":3,"sources":["../../../../src/morphology/german/detectAndStemRegularParticiple.js"],"names":["detectAndStemRegularParticiple","detectAndStemParticiplesWithoutPrefixes","morphologyDataVerbs","word","geStemTParticipleRegex","RegExp","participleStemmingClasses","regex","geStemEtParticipleRegex","test","slice","length","detectAndStemParticiplePerPrefixClass","prefixes","regexPart","startStem","endStem","currentPrefix","participleRegex","wordWithoutPrefix","wordWithoutParticipleAffixes","detectAndStemParticiplesWithPrefixes","prefixesSeparableOrInseparable","separableOrInseparable","participleClass","separable","inseparable","stem","includes"],"mappings":";;;;;QA6GgBA,8B,GAAAA,8B;;AA7GhB;;;;AACA;;;;AAEA;;;;;;;;AAQA,MAAMC,0CAA0C,SAA1CA,uCAA0C,CAAUC,mBAAV,EAA+BC,IAA/B,EAAsC;AACrF,OAAMC,yBAAyB,IAAIC,MAAJ,CAAY,MAAMH,oBAAoBI,yBAApB,CAA+C,CAA/C,EAAmDC,KAArE,CAA/B;AACA,OAAMC,0BAA0B,IAAIH,MAAJ,CAAY,MAAMH,oBAAoBI,yBAApB,CAA+C,CAA/C,EAAmDC,KAArE,CAAhC;;AAEA;;;;AAIA,KAAKC,wBAAwBC,IAAxB,CAA8BN,IAA9B,CAAL,EAA4C;AAC3C;AACA,SAASA,KAAKO,KAAL,CAAY,CAAZ,EAAeP,KAAKQ,MAAL,GAAc,CAA7B,CAAT;AACA;;AAED;AACA,KAAKP,uBAAuBK,IAAvB,CAA6BN,IAA7B,CAAL,EAA2C;AAC1C;AACA,SAASA,KAAKO,KAAL,CAAY,CAAZ,EAAeP,KAAKQ,MAAL,GAAc,CAA7B,CAAT;AACA;;AAED,QAAO,IAAP;AACA,CApBD;;AAsBA;;;;;;;;;;;;AAYA,MAAMC,wCAAwC,SAAxCA,qCAAwC,CAAUT,IAAV,EAAgBU,QAAhB,EAA0BC,SAA1B,EAAqCC,SAArC,EAAgDC,OAAhD,EAA0D;AACvG,MAAM,MAAMC,aAAZ,IAA6BJ,QAA7B,EAAwC;AACvC,QAAMK,kBAAkB,IAAIb,MAAJ,CAAY,MAAMY,aAAN,GAAsBH,SAAlC,CAAxB;;AAEA,MAAKI,gBAAgBT,IAAhB,CAAsBN,IAAtB,CAAL,EAAoC;AACnC,SAAMgB,oBAAoBhB,KAAKO,KAAL,CAAYO,cAAcN,MAAd,GAAuBR,KAAKQ,MAAxC,CAA1B;AACA,SAAMS,+BAA+BD,kBAAkBT,KAAlB,CAAyBK,SAAzB,EAAoCI,kBAAkBR,MAAlB,GAA2BK,OAA/D,CAArC;;AAEA,UAASC,gBAAgBG,4BAAzB;AACA;AACD;;AAED,QAAO,IAAP;AACA,CAbD;;AAeA;;;;;;;;AAQA,MAAMC,uCAAuC,SAAvCA,oCAAuC,CAAUnB,mBAAV,EAA+BC,IAA/B,EAAsC;AAClF,OAAMmB,iCAAiCpB,oBAAoBW,QAApB,CAA6BU,sBAApE;;AAEA;;;;AAIA,MAAM,MAAMC,eAAZ,IAA+BtB,oBAAoBI,yBAAnD,EAA+E;AAC9E,QAAMC,QAAQiB,gBAAgBjB,KAA9B;AACA,QAAMQ,YAAYS,gBAAgBT,SAAlC;AACA,QAAMC,UAAUQ,gBAAgBR,OAAhC;AACA,QAAMS,YAAYD,gBAAgBC,SAAlC;;AAEA,QAAMZ,WAAWY,YACdvB,oBAAoBW,QAApB,CAA6BY,SADf,GAEdvB,oBAAoBW,QAApB,CAA6Ba,WAFhC;;AAIA,MAAIC,OAAOf,sCAAuCT,IAAvC,EAA6CU,QAA7C,EAAuDN,KAAvD,EAA8DQ,SAA9D,EAAyEC,OAAzE,CAAX;;AAEA,MAAKW,IAAL,EAAY;AACX,UAAOA,IAAP;AACA;;AAEDA,SAAOf,sCAAuCT,IAAvC,EAA6CmB,8BAA7C,EAA6Ef,KAA7E,EAAoFQ,SAApF,EAA+FC,OAA/F,CAAP;;AAEA,MAAKW,IAAL,EAAY;AACX,UAAOA,IAAP;AACA;AACD;;AAED,QAAO,IAAP;AACA,CA/BD;;AAiCA;;;;;;;;AAQO,SAAS3B,8BAAT,CAAyCE,mBAAzC,EAA8DC,IAA9D,EAAqE;AAC3E,KAAK,uBAAYA,IAAZ,EAAmBQ,MAAnB,GAA4B,CAA5B,IAAiC,6CAA8BiB,QAA9B,CAAwCzB,IAAxC,CAAtC,EAAuF;AACtF,SAAO,EAAP;AACA;;AAED,KAAIwB,OAAO1B,wCAAyCC,mBAAzC,EAA8DC,IAA9D,CAAX;;AAEA,KAAKwB,IAAL,EAAY;AACX,SAAOA,IAAP;AACA;;AAEDA,QAAON,qCAAsCnB,mBAAtC,EAA2DC,IAA3D,CAAP;;AAEA,KAAKwB,IAAL,EAAY;AACX,SAAOA,IAAP;AACA;;AAED,QAAO,IAAP;AACA","file":"detectAndStemRegularParticiple.js","sourcesContent":["import exceptionsParticiplesActive from \"../../researches/german/passiveVoice/exceptionsParticiplesActive\";\nimport { exceptions } from \"../../researches/german/passiveVoice/regex\";\n\n/**\n * Detects whether a word is a regular participle without a prefix and if so, returns the stem.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {string}  word                The word (not stemmed) to check.\n *\n * @returns {string|null} The stem or null if no participle was matched.\n */\nconst detectAndStemParticiplesWithoutPrefixes = function( morphologyDataVerbs, word ) {\n\tconst geStemTParticipleRegex = new RegExp( \"^\" + morphologyDataVerbs.participleStemmingClasses[ 1 ].regex );\n\tconst geStemEtParticipleRegex = new RegExp( \"^\" + morphologyDataVerbs.participleStemmingClasses[ 0 ].regex );\n\n\t/*\n\t * Check if it's a ge + stem ending in d/t + et participle.\n\t * As this is the more specific regex, it needs to be checked before the ge + stem + t regex.\n\t */\n\tif ( geStemEtParticipleRegex.test( word ) ) {\n\t\t// Remove the two-letter prefix and the two-letter suffix.\n\t\treturn ( word.slice( 2, word.length - 2 ) );\n\t}\n\n\t// Check if it's a ge + stem + t participle.\n\tif ( geStemTParticipleRegex.test( word ) ) {\n\t\t// Remove the two-letter prefix and the one-letter suffix.\n\t\treturn ( word.slice( 2, word.length - 1 ) );\n\t}\n\n\treturn null;\n};\n\n/**\n * Determines whether a given participle pattern combined with prefixes from a given class applies to a given word\n * and if so, returns the stem.\n *\n * @param {string}      word        The word (not stemmed) to check.\n * @param {string[]}    prefixes    The prefixes of a certain prefix class.\n * @param {string}      regexPart   The regex part for a given class (completed to a full regex within the function).\n * @param {number}      startStem   Where to start cutting off the de-prefixed word.\n * @param {number}      endStem     Where to end cutting off the de-prefixed word (from the end index).\n *\n * @returns {string|null} The stem or null if no prefixed participle was matched.\n */\nconst detectAndStemParticiplePerPrefixClass = function( word, prefixes, regexPart, startStem, endStem ) {\n\tfor ( const currentPrefix of prefixes ) {\n\t\tconst participleRegex = new RegExp( \"^\" + currentPrefix + regexPart );\n\n\t\tif ( participleRegex.test( word ) ) {\n\t\t\tconst wordWithoutPrefix = word.slice( currentPrefix.length - word.length );\n\t\t\tconst wordWithoutParticipleAffixes = wordWithoutPrefix.slice( startStem, wordWithoutPrefix.length - endStem );\n\n\t\t\treturn ( currentPrefix + wordWithoutParticipleAffixes );\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Detects whether a word is a regular participle with a prefix and if so, returns the stem.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {string}  word                The word (not stemmed) to check.\n *\n * @returns {string|null} The stem or null if no participle with prefix was matched.\n */\nconst detectAndStemParticiplesWithPrefixes = function( morphologyDataVerbs, word ) {\n\tconst prefixesSeparableOrInseparable = morphologyDataVerbs.prefixes.separableOrInseparable;\n\n\t/*\n\t * It's important to preserve order here, since the ge + stem ending in d/t + et regex is more specific than\n\t * the ge + stem + t regex, and therefore must be checked first.\n\t */\n\tfor ( const participleClass of morphologyDataVerbs.participleStemmingClasses ) {\n\t\tconst regex = participleClass.regex;\n\t\tconst startStem = participleClass.startStem;\n\t\tconst endStem = participleClass.endStem;\n\t\tconst separable = participleClass.separable;\n\n\t\tconst prefixes = separable\n\t\t\t? morphologyDataVerbs.prefixes.separable\n\t\t\t: morphologyDataVerbs.prefixes.inseparable;\n\n\t\tlet stem = detectAndStemParticiplePerPrefixClass( word, prefixes, regex, startStem, endStem );\n\n\t\tif ( stem ) {\n\t\t\treturn stem;\n\t\t}\n\n\t\tstem = detectAndStemParticiplePerPrefixClass( word, prefixesSeparableOrInseparable, regex, startStem, endStem );\n\n\t\tif ( stem ) {\n\t\t\treturn stem;\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Detects whether a word is a regular participle and if so, returns the stem.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {string}  word                The word (not stemmed) to check.\n *\n * @returns {string} The participle stem or null if no regular participle was matched.\n */\nexport function detectAndStemRegularParticiple( morphologyDataVerbs, word ) {\n\tif ( exceptions( word ).length > 0 || exceptionsParticiplesActive().includes( word ) ) {\n\t\treturn \"\";\n\t}\n\n\tlet stem = detectAndStemParticiplesWithoutPrefixes( morphologyDataVerbs, word );\n\n\tif ( stem ) {\n\t\treturn stem;\n\t}\n\n\tstem = detectAndStemParticiplesWithPrefixes( morphologyDataVerbs, word );\n\n\tif ( stem ) {\n\t\treturn stem;\n\t}\n\n\treturn null;\n}\n"]}