{"version":3,"sources":["../../../../src/morphology/german/stem.js"],"names":["stem","determineR1","word","r1Index","search","findSuffixStep1","a1Index","b1Index","c1Index","optionUsed1","index1","findSuffixStep2","a2Index","b2Index","index2","deleteSuffix1","substring","length","deleteSuffix2","stemIrregularVerbs","morphologyDataVerbs","irregularVerbs","veryIrregularVerbs","matchedParadigm","find","paradigm","forms","includes","veryIrregularVerbStem","replace"],"mappings":"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","file":"stem.js","sourcesContent":["/**\n * @file German stemming algorithm. Adapted from:\n * @author: Joder Illi\n * @copyright (c) 2010, FormBlitz AG\n * All rights reserved.\n * Implementation of the stemming algorithm from http://snowball.tartarus.org/algorithms/german/stemmer.html\n * Copyright of the algorithm is: Copyright (c) 2001, Dr Martin Porter and can be found at http://snowball.tartarus.org/license.php\n *\n * Redistribution and use in source and binary forms, with or without modification, is covered by the standard BSD license.\n */\n/**\n * Determines the start index of the R1 region.\n * R1 is the region after the first non-vowel following a vowel. It should include at least 3 letters.\n *\n * @param {string} word The word for which to determine the R1 region.\n * @returns {number} The start index of the R1 region.\n */\nconst determineR1 = function( word ) {\n\t// Start with matching first vowel and non-vowel.\n\tlet r1Index = word.search( /[aeiouyäöü][^aeiouyäöü]/ );\n\t// Then add 2 since the R1 index is the index after the first vowel & non-vowel matched with the regex.\n\tif ( r1Index !== -1 ) {\n\t\tr1Index += 2;\n\t}\n\n\t// Adjust R1 so that the region preceding it includes at least 3 letters.\n\tif ( r1Index !== -1 && r1Index < 3 ) {\n\t\tr1Index = 3;\n\t}\n\n\treturn r1Index;\n};\n\n/**\n * Search for the longest among the following suffixes,\n * (a) em   ern   er\n * (b) e   en   es\n * (c) s (preceded by a valid s-ending)\n * Define a valid s-ending as one of b, d, f, g, h, k, l, m, n, r or t.\n *\n * @param {string} word The word to check for the suffix.\n * @returns {{index1: number, optionUsed1: string}} The index of the suffix and the kind of suffix used.\n */\nconst findSuffixStep1 = function( word ) {\n\tconst a1Index = word.search( /(em|ern|er)$/g );\n\tconst b1Index = word.search( /(e|en|es)$/g );\n\tlet c1Index = word.search( /([bdfghklmnrt]s)$/g );\n\t// Exclude the s-ending before the s.\n\tif ( c1Index !== -1 ) {\n\t\tc1Index++;\n\t}\n\tlet optionUsed1 = \"\";\n\tlet index1 = 10000;\n\tif ( a1Index !== -1 ) {\n\t\toptionUsed1 = \"a\";\n\t\tindex1 = a1Index;\n\n\t\treturn { index1, optionUsed1 };\n\t} else if ( b1Index !== -1 ) {\n\t\toptionUsed1 = \"b\";\n\t\tindex1 = b1Index;\n\n\t\treturn { index1, optionUsed1 };\n\t} else if ( c1Index !== -1 ) {\n\t\toptionUsed1 = \"c\";\n\t\tindex1 = c1Index;\n\n\t\treturn { index1, optionUsed1 };\n\t}\n\n\treturn { index1, optionUsed1 };\n};\n\n/**\n * Search for the longest among the following suffixes,\n * (a) en   er   est\n * (b) st (preceded by a valid st-ending, itself preceded by at least 3 letters)\n * Define a valid st-ending as one of b, d, f, g, h, k, l, m, n or t.\n *\n * @param {string} word The word to check for the suffix.\n * @returns {number} The index of the suffix.\n */\nconst findSuffixStep2 = function( word ) {\n\tconst a2Index = word.search( /(en|er|est)$/g );\n\tlet b2Index = word.search( /(.{3}[bdfghklmnt]st)$/g );\n\t// Exclude the st-ending and the preceding 3 letters.\n\tif ( b2Index !== -1 ) {\n\t\tb2Index += 4;\n\t}\n\tlet index2 = 10000;\n\tif ( a2Index !== -1 ) {\n\t\tindex2 = a2Index;\n\t} else if ( b2Index !== -1  ) {\n\t\tindex2 = b2Index;\n\t}\n\n\treturn index2;\n};\n\n/**\n * Delete the suffix found in step 1 if in R1. (The letter of the valid s-ending is not necessarily in R1.)\n * If an ending of group (b) is deleted, and the ending is preceded by niss, delete the final s.\n * (For example, äckern -> äck, ackers -> acker, armes -> arm, bedürfnissen -> bedürfnis).\n *\n * @param {string} word         The word for which to delete the suffix.\n * @param {number} index1       The index of the suffix found in step 1.\n * @param {string} optionUsed1  The type of the suffix found in step 1.\n * @param {number} r1Index      The R1 index.\n *\n * @returns {string} The word with the deleted suffix.\n */\nconst deleteSuffix1 = function( word, index1, optionUsed1, r1Index ) {\n\tif ( index1 !== 10000 && r1Index !== -1 ) {\n\t\tif ( index1 >= r1Index ) {\n\t\t\tword = word.substring( 0, index1 );\n\t\t\tif ( optionUsed1 === \"b\" ) {\n\t\t\t\tif ( word.search( /niss$/ ) !== -1 ) {\n\t\t\t\t\tword = word.substring( 0, word.length - 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn word;\n};\n\n/**\n * Delete the suffix found in step 2 if in R1.\n * (For example, derbsten -> derbst by step 1, and derbst -> derb by step 2,\n * since b is a valid st-ending, and is preceded by just 3 letters).\n *\n * @param {string} word     The word for which to delete the suffix.\n * @param {number} index2   The index of the suffix found in step 2.\n * @param {number} r1Index  The R1 index.\n *\n * @returns {string} The word with the deleted suffix.\n */\nconst deleteSuffix2 = function( word, index2, r1Index ) {\n\tif ( index2 !== 10000 && r1Index !== -1 ) {\n\t\tif ( index2 >= r1Index ) {\n\t\t\tword = word.substring( 0, index2 );\n\t\t}\n\t}\n\treturn word;\n};\n\n\n/**\n * Stems irregular verbs.\n *\n * @param {Object} morphologyDataVerbs  The German morphology data for verbs.\n * @param {string} word                 The word to stem.\n *\n * @returns {string} The stemmed word.\n */\nconst stemIrregularVerbs = function( morphologyDataVerbs, word ) {\n\tconst irregularVerbs = morphologyDataVerbs.veryIrregularVerbs;\n\n\tconst matchedParadigm = irregularVerbs.find( paradigm => {\n\t\tconst forms = paradigm.forms;\n\t\treturn forms.includes( word );\n\t} );\n\n\tif ( matchedParadigm ) {\n\t\treturn matchedParadigm.stem;\n\t}\n\n\treturn null;\n};\n\n/**\n * Stems German words.\n *\n * @param {Object} morphologyDataVerbs  The German morphology data for verbs.\n * @param {string} word                 The word to stem.\n *\n * @returns {string} The stemmed word.\n */\nexport default function stem( morphologyDataVerbs, word ) {\n\t// Check if word is a very irregular verb, and if so, return its stem.\n\tconst veryIrregularVerbStem = stemIrregularVerbs( morphologyDataVerbs, word );\n\n\tif ( veryIrregularVerbStem ) {\n\t\treturn veryIrregularVerbStem;\n\t}\n\n\t// Put u and y between vowels into upper case.\n\tword = word.replace( /([aeiouyäöü])u([aeiouyäöü])/g, \"$1U$2\" );\n\tword = word.replace( /([aeiouyäöü])y([aeiouyäöü])/g, \"$1Y$2\" );\n\tword = word.replace( /([aeiouyäöü])i([aeiouyäöü])/g, \"$1I$2\" );\n\tword = word.replace( /([aeiouyäöü])e([aeiouyäöü])/g, \"$1E$2\" );\n\n\t// Find the start index of the R1 region.\n\tconst r1Index = determineR1( word );\n\n\t// Find suffixes as defined in step 1.\n\tconst index1 = findSuffixStep1( word ).index1;\n\tconst optionUsed1 = findSuffixStep1( word ).optionUsed1;\n\n\t// Delete the suffix found in step 1.\n\tword = deleteSuffix1( word, index1, optionUsed1, r1Index );\n\n\t// Find suffixes as defined in step 2.\n\tconst index2 = findSuffixStep2( word );\n\n\t// Delete the suffix found in step 2.\n\tword = deleteSuffix2( word, index2, r1Index );\n\n\t// Turn U and Y back into lower case.\n\tword = word.replace( /U/g, \"u\" );\n\tword = word.replace( /Y/g, \"y\" );\n\tword = word.replace( /I/g, \"i\" );\n\tword = word.replace( /E/g, \"e\" );\n\n\treturn word;\n}\n"]}