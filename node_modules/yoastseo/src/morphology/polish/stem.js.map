{"version":3,"sources":["../../../../src/morphology/polish/stem.js"],"names":["stem","endsInArr","word","endings","matches","i","endsWith","push","longest","sort","a","b","length","findSuffixInGroupAndStem","wordLength","wordEndings","suffixLength","longestMatchedWordEnding","slice","findSuffixInClassAndStem","suffixClass","suffixGroup","hasOwnProperty","wordShouldBeLongerThan","stemmedWord","stemAdjectivesAndAdverbs","ruleBasedStemmerData","adjectiveAndAdverbSuffixes","startsWith","superlativePrefix","morphologyData","externalStemmer","dictionaryStemmer","dictionary","stems","toLowerCase","diminutiveSuffixes","nounSuffixes","verbSuffixes","generalSuffixes"],"mappings":"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","file":"stem.js","sourcesContent":["/**\n * Copyright (c) 2017 Błażej Kubiński\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/**\n * Loops through an array of word endings and returns the longest ending that was matched at the end of the word.\n *\n * @param {string}      word       The word to check.\n * @param {string[]}    endings    The word endings to check.\n * @returns {string}    The longest matched ending.\n */\nconst endsInArr = function( word, endings ) {\n\tconst matches = [];\n\tfor ( const i in endings ) {\n\t\tif ( word.endsWith( endings[ i ] ) ) {\n\t\t\tmatches.push( endings[ i ] );\n\t\t}\n\t}\n\n\tconst longest = matches.sort( function( a, b ) {\n\t\treturn b.length - a.length;\n\t} )[ 0 ];\n\n\tif ( longest ) {\n\t\treturn longest;\n\t}\n\treturn \"\";\n};\n\n/**\n * Checks if a word is longer than the word length threshold specified for a given suffix group. If the word length does not\n * meet the threshold, it is not stemmed.\n *\n * If it does meet the threshold, checks whether the word ends with one of the endings from the inputted array. If it does,\n * it removes the suffix from the end of the word.\n *\n * The length of the actual suffix is not always equal to the length of the checked ending, so suffix length is a separate\n * parameter. For example, the word 'rowerek' ends with -erek, one of the endings from the diminutive group. However, for\n * that ending, the suffix length is defined as 2 so only -ek is stemmed.\n *\n * @param {string} word            The word to stem.\n * @param {number} wordLength      The length of the word.\n * @param {string[]} wordEndings   The suffix group.\n * @param {number} suffixLength    The length of the suffix.\n *\n * @returns {string}               The stemmed word.\n */\nconst findSuffixInGroupAndStem = function( word, wordLength, wordEndings, suffixLength ) {\n\tif ( word.length > wordLength ) {\n\t\tconst longestMatchedWordEnding = endsInArr( word, wordEndings );\n\n\t\tif ( longestMatchedWordEnding !== \"\" ) {\n\t\t\treturn word.slice( 0, -suffixLength );\n\t\t}\n\t}\n};\n\n/**\n * Goes through all the suffix groups in a given class (i.e., diminutive, noun, verb, adjective/adverb or general) and\n * stems the word if a suffix is found and should be stemmed.\n *\n * @param {string}      word            The word to stem.\n * @param {Object}      suffixClass     The class of suffixes to check.\n * @returns {string}    The stemmed word.\n */\nconst findSuffixInClassAndStem = function( word, suffixClass ) {\n\tfor ( const suffixGroup in suffixClass ) {\n\t\tif ( suffixClass.hasOwnProperty( suffixGroup ) ) {\n\t\t\tconst wordShouldBeLongerThan = suffixClass[ suffixGroup ].wordShouldBeLongerThan;\n\t\t\tconst wordEndings = suffixClass[ suffixGroup ].wordEndings;\n\t\t\tconst suffixLength = suffixClass[ suffixGroup ].suffixLength;\n\n\t\t\tconst stemmedWord = findSuffixInGroupAndStem( word, wordShouldBeLongerThan, wordEndings, suffixLength );\n\n\t\t\tif ( stemmedWord ) {\n\t\t\t\treturn stemmedWord;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Stems adjective and adverb suffixes. After stemming the suffixes, looks for the superlative prefix 'naj' and stems it\n * as well if found. For example, in 'najsilniejsze', first the 'ejsze' is stemmed and then the 'naj'.\n *\n * @param {string}  word                \tThe word to stem.\n * @param {Object}  ruleBasedStemmerData    The data for the rule-based stemmer.\n *\n * @returns {string} The word with removed adjective/adverb suffixes\n */\nconst stemAdjectivesAndAdverbs = function( word, ruleBasedStemmerData ) {\n\tconst stemmedWord = findSuffixInClassAndStem( word, ruleBasedStemmerData.adjectiveAndAdverbSuffixes );\n\n\tif ( stemmedWord ) {\n\t\t// Remove superlative prefix if found\n\t\tif ( word.startsWith( ruleBasedStemmerData.superlativePrefix ) ) {\n\t\t\treturn stemmedWord.slice( 3 );\n\t\t}\n\t\treturn stemmedWord;\n\t}\n};\n\n/**\n * Stems Polish words.\n *\n * @param {string}  word                The word to stem.\n * @param {Object}  morphologyData      The Polish morphology data file.\n *\n * @returns {string} The stemmed word.\n */\nexport default function stem( word, morphologyData ) {\n\tconst ruleBasedStemmerData = morphologyData.externalStemmer;\n\tconst dictionaryStemmer = morphologyData.dictionary.stems;\n\n\t// Check if the word exists in the dictionary stemmer. If yes, replace the word with the base form of the word specified in the dictionary.\n\tlet stemmedWord = dictionaryStemmer[ word ];\n\tif ( stemmedWord ) {\n\t\tword = stemmedWord;\n\t}\n\n\tword.toLowerCase();\n\n\t// If the word is three characters long or shorter, the stem should be the same as the word.\n\tif ( word.length < 4 ) {\n\t\treturn word;\n\t}\n\n\t/*\n\t * Go through diminutive, noun, verb, and adjective stemming steps. If a suffix (and optional prefix in case of adjectives/adverbs)\n\t *  is found, delete it and stop searching further.\n\t */\n\tstemmedWord = findSuffixInClassAndStem( word, ruleBasedStemmerData.diminutiveSuffixes );\n\n\tif ( ! stemmedWord ) {\n\t\tstemmedWord = findSuffixInClassAndStem( word, ruleBasedStemmerData.nounSuffixes );\n\t}\n\n\tif ( ! stemmedWord ) {\n\t\tstemmedWord = findSuffixInClassAndStem( word, ruleBasedStemmerData.verbSuffixes );\n\t}\n\n\tif ( ! stemmedWord ) {\n\t\tstemmedWord = stemAdjectivesAndAdverbs( word, ruleBasedStemmerData );\n\t}\n\n\t// If the word was stemmed in any of the previous steps, replace the word with the stem.\n\tif ( stemmedWord ) {\n\t\tword = stemmedWord;\n\t}\n\n\t// Find and stem general suffixes\n\tstemmedWord = findSuffixInClassAndStem( word, ruleBasedStemmerData.generalSuffixes );\n\n\tif ( stemmedWord ) {\n\t\treturn stemmedWord;\n\t}\n\n\treturn word;\n}\n"]}