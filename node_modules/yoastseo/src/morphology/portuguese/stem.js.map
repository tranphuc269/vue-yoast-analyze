{"version":3,"sources":["../../../../src/morphology/portuguese/stem.js"],"names":["stem","isVowel","character","vowels","includes","nextVowelPosition","word","start","length","position","nextConsonantPosition","replaceCharacters","charactersToReplace","replacements","i","replace","stemStandardSuffixes","standardSuffixData","r1Text","r2Text","rvText","regions","r1","r2","rv","suffixGroup","standardGroups","foundSuffix","region","suffixes","slice","replacement","specialEnding","specialClass","wordEndingsToCheck","stemVerbSuffixes","verbSuffixes","verbSuffix","stemResidualSuffixes","residualSuffixData","foundSuffixUe","groupUe","foundSuffixIe","groupIe","foundSuffixE","groupESuffixes","endsWith","cCedilla","morphologyData","toLowerCase","externalStemmer","nasalVowels","originals","nasalVowelsReplacement","wordAfterStep1","standardSuffixes","wordAfterStep2","ciToC","foundGeneralSuffix","generalSuffixes","residualSuffixes"],"mappings":";;;;;kBA+LwBA,I;;AAxKxB;;AAGA;;;;;;;;AAQA,MAAMC,UAAU,SAAVA,OAAU,CAAUC,SAAV,EAAqBC,MAArB,EAA8B;AAC7C,QAAOA,OAAOC,QAAP,CAAiBF,SAAjB,CAAP;AACA,CAFD;;AAIA;;;;;;;;;;AAtCA;;AAEA;;;;;;;;;;;;;;;;;;;;;AA8CA,MAAMG,oBAAoB,SAApBA,iBAAoB,CAAUC,IAAV,EAAgBH,MAAhB,EAAwBI,QAAQ,CAAhC,EAAoC;AAC7D,OAAMC,SAASF,KAAKE,MAApB;;AAEA,MAAM,IAAIC,WAAWF,KAArB,EAA4BE,WAAWD,MAAvC,EAA+CC,UAA/C,EAA4D;AAC3D,MAAKR,QAASK,KAAMG,QAAN,CAAT,EAA2BN,MAA3B,CAAL,EAA2C;AAC1C,UAAOM,QAAP;AACA;AACD;;AAED,QAAOD,MAAP;AACA,CAVD;;AAYA;;;;;;;;;;AAUA,MAAME,wBAAwB,SAAxBA,qBAAwB,CAAUJ,IAAV,EAAgBH,MAAhB,EAAwBI,QAAQ,CAAhC,EAAoC;AACjE,OAAMC,SAASF,KAAKE,MAApB;;AAEA,MAAM,IAAIC,WAAWF,KAArB,EAA4BE,WAAWD,MAAvC,EAA+CC,UAA/C,EAA4D;AAC3D,MAAK,CAAER,QAASK,KAAMG,QAAN,CAAT,EAA2BN,MAA3B,CAAP,EAA6C;AAC5C,UAAOM,QAAP;AACA;AACD;;AAED,QAAOD,MAAP;AACA,CAVD;;AAYA;;;;;;;;;AASA,MAAMG,oBAAoB,SAApBA,iBAAoB,CAAUL,IAAV,EAAgBM,mBAAhB,EAAqCC,YAArC,EAAoD;AAC7E,MAAM,IAAIC,IAAI,CAAd,EAAiBA,IAAIF,oBAAoBJ,MAAzC,EAAiDM,GAAjD,EAAuD;AACtDR,SAAOA,KAAKS,OAAL,CAAcH,oBAAqBE,CAArB,CAAd,EAAwCD,aAAcC,CAAd,CAAxC,CAAP;AACA;;AAED,QAAOR,IAAP;AACA,CAND;;AAQA;;;;;;;;;;;;;;;AAeA,MAAMU,uBAAuB,SAAvBA,oBAAuB,CAAUV,IAAV,EAAgBW,kBAAhB,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,MAApD,EAA6D;AACzF,OAAMC,UAAU;AACfC,MAAIJ,MADW;AAEfK,MAAIJ,MAFW;AAGfK,MAAIJ;AAHW,EAAhB;;AAMA,MAAM,MAAMK,WAAZ,IAA2BR,mBAAmBS,cAA9C,EAA+D;AAC9D,QAAMC,cAAc,0DAA2BN,QAASI,YAAYG,MAArB,CAA3B,EAA0DH,YAAYI,QAAtE,CAApB;;AAEA,MAAKF,WAAL,EAAmB;AAClB,UAAOrB,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACH,YAAYnB,MAA5B,IAAuCiB,YAAYM,WAA1D;AACA;AACD;;AAED,OAAMC,gBAAgB,0DAA2BX,QAASJ,mBAAmBgB,YAAnB,CAAgCL,MAAzC,CAA3B,EAA8EX,mBAAmBgB,YAAnB,CAAgCJ,QAA9G,CAAtB;AACA,KAAK,0DAA2BvB,IAA3B,EAAiCW,mBAAmBgB,YAAnB,CAAgCC,kBAAjE,KAAyFF,aAA9F,EAA+G;AAC9G1B,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACE,cAAcxB,MAA9B,IAAyCS,mBAAmBgB,YAAnB,CAAgCF,WAAhF;AACA;;AAED,QAAOzB,IAAP;AACA,CArBD;;AAuBA;;;;;;;;;AASA,MAAM6B,mBAAmB,SAAnBA,gBAAmB,CAAU7B,IAAV,EAAgB8B,YAAhB,EAA8BhB,MAA9B,EAAuC;AAC/D,OAAMiB,aAAa,0DAA2BjB,MAA3B,EAAmCgB,YAAnC,CAAnB;;AAEA,KAAKC,eAAe,EAApB,EAAyB;AACxB/B,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACO,WAAW7B,MAA3B,CAAP;AACA;;AAED,QAAOF,IAAP;AACA,CARD;;AAUA;;;;;;;;;AASA,MAAMgC,uBAAuB,SAAvBA,oBAAuB,CAAUhC,IAAV,EAAgBiC,kBAAhB,EAAoCnB,MAApC,EAA6C;AACzE,OAAMoB,gBAAgB,0DAA2BpB,MAA3B,EAAmCmB,mBAAmBE,OAAnB,CAA2BZ,QAA9D,CAAtB;AACA,OAAMa,gBAAgB,0DAA2BtB,MAA3B,EAAmCmB,mBAAmBI,OAAnB,CAA2Bd,QAA9D,CAAtB;AACA,OAAMe,eAAe,0DAA2BxB,MAA3B,EAAmCmB,mBAAmBM,cAAtD,CAArB;;AAEA,KAAKL,iBAAiB,0DAA2BlC,IAA3B,EAAiCiC,mBAAmBE,OAAnB,CAA2BP,kBAA5D,CAAtB,EAAyG;AACxG5B,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACU,cAAchC,MAA9B,CAAP;AACA,EAFD,MAEO,IAAKkC,iBAAiB,0DAA2BpC,IAA3B,EAAiCiC,mBAAmBI,OAAnB,CAA2BT,kBAA5D,CAAtB,EAAyG;AAC/G5B,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACY,cAAclC,MAA9B,CAAP;AACA,EAFM,MAEA,IAAKoC,YAAL,EAAoB;AAC1BtC,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAACc,aAAapC,MAA7B,CAAP;AACA,EAFM,MAEA,IAAKF,KAAKwC,QAAL,CAAeP,mBAAmBQ,QAAnB,CAA6B,CAA7B,CAAf,CAAL,EAAyD;AAC/DzC,SAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAAC,CAAhB,IAAsBS,mBAAmBQ,QAAnB,CAA6B,CAA7B,CAA7B;AACA;;AAED,QAAOzC,IAAP;AACA,CAhBD;;AAkBA;;;;;;;;AAQe,SAASN,IAAT,CAAeM,IAAf,EAAqB0C,cAArB,EAAsC;AACpD1C,MAAK2C,WAAL;AACA,OAAM9C,SAAS6C,eAAeE,eAAf,CAA+B/C,MAA9C;;AAEA;AACA,OAAMgD,cAAcH,eAAeE,eAAf,CAA+BC,WAA/B,CAA2CC,SAA/D;AACA,OAAMC,yBAAyBL,eAAeE,eAAf,CAA+BC,WAA/B,CAA2CtC,YAA1E;AACAP,QAAOK,kBAAmBL,IAAnB,EAAyB6C,WAAzB,EAAsCE,sBAAtC,CAAP;;AAEA,OAAM7C,SAASF,KAAKE,MAApB;AACA,KAAKA,SAAS,CAAd,EAAkB;AACjB,SAAOF,IAAP;AACA;;AAED,KAAIgB,KAAKd,MAAT;AACA,KAAIe,KAAKf,MAAT;AACA,KAAIgB,KAAKhB,MAAT;;AAEA;;;;AAIA,MAAM,IAAIM,IAAI,CAAd,EAAiBA,IAAMN,SAAS,CAAf,IAAsBc,OAAOd,MAA9C,EAAsDM,GAAtD,EAA4D;AAC3D,MAAKb,QAASK,KAAMQ,CAAN,CAAT,EAAoBX,MAApB,KAAgC,CAAEF,QAASK,KAAMQ,IAAI,CAAV,CAAT,EAAwBX,MAAxB,CAAvC,EAA0E;AACzEmB,QAAKR,IAAI,CAAT;AACA;AACD;;AAED;;;;AAIA,MAAM,IAAIA,IAAIQ,EAAd,EAAkBR,IAAMN,SAAS,CAAf,IAAsBe,OAAOf,MAA/C,EAAuDM,GAAvD,EAA6D;AAC5D,MAAKb,QAASK,KAAMQ,CAAN,CAAT,EAAoBX,MAApB,KAAgC,CAAEF,QAASK,KAAMQ,IAAI,CAAV,CAAT,EAAwBX,MAAxB,CAAvC,EAA0E;AACzEoB,QAAKT,IAAI,CAAT;AACA;AACD;;AAED;;;;;AAKA,KAAKN,SAAS,CAAd,EAAkB;AACjB,MAAK,CAAEP,QAASK,KAAM,CAAN,CAAT,EAAoBH,MAApB,CAAP,EAAsC;AACrCqB,QAAKnB,kBAAmBC,IAAnB,EAAyBH,MAAzB,EAAiC,CAAjC,IAAuC,CAA5C;AACA,GAFD,MAEO,IAAKF,QAASK,KAAM,CAAN,CAAT,EAAoBH,MAApB,KAAgCF,QAASK,KAAM,CAAN,CAAT,EAAoBH,MAApB,CAArC,EAAoE;AAC1EqB,QAAKd,sBAAuBJ,IAAvB,EAA6BH,MAA7B,EAAqC,CAArC,IAA2C,CAAhD;AACA,GAFM,MAEA;AACNqB,QAAK,CAAL;AACA;AACD;;AAED,OAAMN,SAASZ,KAAKwB,KAAL,CAAYR,EAAZ,CAAf;AACA,OAAMH,SAASb,KAAKwB,KAAL,CAAYP,EAAZ,CAAf;AACA,KAAIH,SAASd,KAAKwB,KAAL,CAAYN,EAAZ,CAAb;;AAEA;AACA,OAAM8B,iBAAiBtC,qBAAsBV,IAAtB,EAA4B0C,eAAeE,eAAf,CAA+BK,gBAA3D,EAA6ErC,MAA7E,EAAqFC,MAArF,EAA6FC,MAA7F,CAAvB;;AAEA;AACA,KAAIoC,iBAAiB,EAArB;;AAEA,KAAKlD,SAASgD,cAAd,EAA+B;AAC9BE,mBAAiBrB,iBAAkB7B,IAAlB,EAAwB0C,eAAeE,eAAf,CAA+Bd,YAAvD,EAAqEhB,MAArE,CAAjB;AACA;;AAED;AACA,KAAKd,SAASgD,cAAd,EAA+B;AAC9BhD,SAAOgD,cAAP;AACAlC,WAASd,KAAKwB,KAAL,CAAYN,EAAZ,CAAT;AACA,EAHD,MAGO,IAAKlB,SAASkD,cAAd,EAA+B;AACrClD,SAAOkD,cAAP;AACApC,WAASd,KAAKwB,KAAL,CAAYN,EAAZ,CAAT;AACA;;AAED;;;;AAIA,KAAK8B,mBAAmBhD,IAAnB,IAA2BkD,mBAAmBlD,IAAnD,EAA0D;AACzD,MAAKA,KAAKwC,QAAL,CAAeE,eAAeE,eAAf,CAA+BO,KAA/B,CAAsC,CAAtC,CAAf,KAA8DrC,OAAO0B,QAAP,CAAiBE,eAAeE,eAAf,CAA+BO,KAA/B,CAAsC,CAAtC,CAAjB,CAAnE,EAAkI;AACjInD,UAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAP;AACAV,YAASd,KAAKwB,KAAL,CAAYN,EAAZ,CAAT;AACA;AACD,EALD,MAKO;AACN,QAAMkC,qBAAqB,0DAA2BtC,MAA3B,EAAmC4B,eAAeE,eAAf,CAA+BS,eAAlE,CAA3B;AACA,MAAKD,uBAAuB,EAA5B,EAAiC;AAChCpD,UAAOA,KAAKwB,KAAL,CAAY,CAAZ,EAAe,CAAC4B,mBAAmBlD,MAAnC,CAAP;AACAY,YAASd,KAAKwB,KAAL,CAAYN,EAAZ,CAAT;AACA;AACD;;AAED;AACAlB,QAAOgC,qBAAsBhC,IAAtB,EAA4B0C,eAAeE,eAAf,CAA+BU,gBAA3D,EAA6ExC,MAA7E,CAAP;;AAEA;AACAd,QAAOK,kBAAmBL,IAAnB,EAAyB+C,sBAAzB,EAAiDF,WAAjD,CAAP;;AAEA,QAAO7C,IAAP;AACA","file":"stem.js","sourcesContent":["/* eslint-disable max-statements, complexity */\n\n/*\nCopyright (c) 2015, Luís Rodrigues\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nimport { findMatchingEndingInArray } from \"../morphoHelpers/findMatchingEndingInArray\";\n\n\n/**\n * Checks whether the character is a vowel.\n *\n * @param {string}\t    character\tThe character to check.\n * @param {string[]}    vowels      The Portuguese vowels.\n *\n * @returns {boolean}\tWhether the character is a vowel.\n */\nconst isVowel = function( character, vowels ) {\n\treturn vowels.includes( character );\n};\n\n/**\n * Finds the first vowel in a string after the specified index and returns the index of the character following that vowel\n * (if found).\n *\n * @param {string}\t    word\t        The word to check.\n * @param {string[]}    vowels          The Portuguese vowels.\n * @param {number}\t    [start=0]       The index at which the search for a vowel should begin.\n *\n * @returns {number} The index of the character following the found vowel. If this is not found, the length of the word.\n */\nconst nextVowelPosition = function( word, vowels, start = 0 ) {\n\tconst length = word.length;\n\n\tfor ( let position = start; position < length; position++ ) {\n\t\tif ( isVowel( word[ position ], vowels ) ) {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\treturn length;\n};\n\n/**\n * Finds the first consonant in a string after the specified index and returns the index of the character following that\n * consonant (if found).\n *\n * @param {string}\t    word\t    The word to check.\n * @param {string[]}    vowels      The Portuguese vowels.\n * @param {number}\t    [start=0]\tThe index at which the search for a consonant should begin.\n *\n * @returns {number} The index of the character following the found consonant. If this is not found, the length of the word.\n */\nconst nextConsonantPosition = function( word, vowels, start = 0 ) {\n\tconst length = word.length;\n\n\tfor ( let position = start; position < length; position++ ) {\n\t\tif ( ! isVowel( word[ position ], vowels ) ) {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\treturn length;\n};\n\n/**\n * Replaces characters with other characters if found in a word.\n *\n * @param {string}\t\tword\t\t\t\tThe word to check.\n * @param {string[]}\tcharactersToReplace\tThe characters to replace.\n * @param {string[]}\treplacements\t\tThe replacement characters.\n *\n * @returns {string}\tThe word with the replacement characters, or the original word if no characters to replace were found.\n */\nconst replaceCharacters = function( word, charactersToReplace, replacements ) {\n\tfor ( let i = 0; i < charactersToReplace.length; i++ ) {\n\t\tword = word.replace( charactersToReplace[ i ], replacements[ i ] );\n\t}\n\n\treturn word;\n};\n\n/**\n * Looks for the longest suffix in each group and removes it if it is found within the specified region (R1, R2 or RV).\n * Once a suffix is found and removed, stops searching further.\n *\n * For some of the suffix groups, replaces the suffix with another string after removing it (e.g. -logia is replaced with\n * -log).\n *\n * @param {string}\tword\t            The word to check.\n * @param {Object}  standardSuffixData  The data for stemming standard suffixes.\n * @param {string}\tr1Text\t            The text in the R1 region.\n * @param {string}\tr2Text\t            The text in the R2 region.\n * @param {string}\trvText\t            The text in the RV region.\n *\n * @returns {string} The stemmed word or the original word if no suffix was removed.\n */\nconst stemStandardSuffixes = function( word, standardSuffixData, r1Text, r2Text, rvText ) {\n\tconst regions = {\n\t\tr1: r1Text,\n\t\tr2: r2Text,\n\t\trv: rvText,\n\t};\n\n\tfor ( const suffixGroup of standardSuffixData.standardGroups ) {\n\t\tconst foundSuffix = findMatchingEndingInArray( regions[ suffixGroup.region ], suffixGroup.suffixes );\n\n\t\tif ( foundSuffix ) {\n\t\t\treturn word.slice( 0, -foundSuffix.length ) + suffixGroup.replacement;\n\t\t}\n\t}\n\n\tconst specialEnding = findMatchingEndingInArray( regions[ standardSuffixData.specialClass.region ], standardSuffixData.specialClass.suffixes );\n\tif ( findMatchingEndingInArray( word, standardSuffixData.specialClass.wordEndingsToCheck ) && specialEnding  ) {\n\t\tword = word.slice( 0, -specialEnding.length ) + standardSuffixData.specialClass.replacement;\n\t}\n\n\treturn word;\n};\n\n/**\n * Stems verb suffixes.\n *\n * @param {string}      word            The original word.\n * @param {string[]}    verbSuffixes    The verb suffixes to check.\n * @param {string}      rvText          The text of the RV.\n *\n * @returns {string} The word with the verb suffixes removed (if applicable).\n */\nconst stemVerbSuffixes = function( word, verbSuffixes, rvText ) {\n\tconst verbSuffix = findMatchingEndingInArray( rvText, verbSuffixes );\n\n\tif ( verbSuffix !== \"\" ) {\n\t\tword = word.slice( 0, -verbSuffix.length );\n\t}\n\n\treturn word;\n};\n\n/**\n * Stems residual suffixes.\n *\n * @param {string}\tword\t            The word to check.\n * @param {Object}  residualSuffixData  The data used to stem residual suffixes.\n * @param {string}\trvText\t            The text in the RV region.\n *\n * @returns {string} The word with a removed suffix, or the original input word if no suffix was removed.\n */\nconst stemResidualSuffixes = function( word, residualSuffixData, rvText ) {\n\tconst foundSuffixUe = findMatchingEndingInArray( rvText, residualSuffixData.groupUe.suffixes );\n\tconst foundSuffixIe = findMatchingEndingInArray( rvText, residualSuffixData.groupIe.suffixes );\n\tconst foundSuffixE = findMatchingEndingInArray( rvText, residualSuffixData.groupESuffixes );\n\n\tif ( foundSuffixUe && findMatchingEndingInArray( word, residualSuffixData.groupUe.wordEndingsToCheck ) ) {\n\t\tword = word.slice( 0, -foundSuffixUe.length );\n\t} else if ( foundSuffixIe && findMatchingEndingInArray( word, residualSuffixData.groupIe.wordEndingsToCheck ) ) {\n\t\tword = word.slice( 0, -foundSuffixIe.length );\n\t} else if ( foundSuffixE ) {\n\t\tword = word.slice( 0, -foundSuffixE.length );\n\t} else if ( word.endsWith( residualSuffixData.cCedilla[ 0 ] ) ) {\n\t\tword = word.slice( 0, -1 ) + residualSuffixData.cCedilla[ 1 ];\n\t}\n\n\treturn word;\n};\n\n/**\n * Stems Portuguese words.\n *\n * @param {string} word             The word to stem.\n * @param {Object} morphologyData   The Portuguese morphology data.\n *\n * @returns {string} The stemmed word.\n */\nexport default function stem( word, morphologyData ) {\n\tword.toLowerCase();\n\tconst vowels = morphologyData.externalStemmer.vowels;\n\n\t// Nasal vowels should be treated as a vowel followed by a consonant.\n\tconst nasalVowels = morphologyData.externalStemmer.nasalVowels.originals;\n\tconst nasalVowelsReplacement = morphologyData.externalStemmer.nasalVowels.replacements;\n\tword = replaceCharacters( word, nasalVowels, nasalVowelsReplacement, );\n\n\tconst length = word.length;\n\tif ( length < 2 ) {\n\t\treturn word;\n\t}\n\n\tlet r1 = length;\n\tlet r2 = length;\n\tlet rv = length;\n\n\t/*\n\t * R1 is the region after the first non-vowel following a vowel, or is the null region at the end of the word if\n\t * there is no such non-vowel.\n\t */\n\tfor ( let i = 0; i < ( length - 1 ) && r1 === length; i++ ) {\n\t\tif ( isVowel( word[ i ], vowels ) && ! isVowel( word[ i + 1 ], vowels ) ) {\n\t\t\tr1 = i + 2;\n\t\t}\n\t}\n\n\t/*\n\t * R2 is the region after the first non-vowel following a vowel in R1, or is the null region at the end of the\n\t * word if there is no such non-vowel.\n\t */\n\tfor ( let i = r1; i < ( length - 1 ) && r2 === length; i++ ) {\n\t\tif ( isVowel( word[ i ], vowels ) && ! isVowel( word[ i + 1 ], vowels ) ) {\n\t\t\tr2 = i + 2;\n\t\t}\n\t}\n\n\t/*\n\t * If the second letter is a consonant, RV is the region after the next following vowel. If the first two letters are\n\t * vowels, RV is the region after the next consonant, and otherwise (consonant-vowel case) RV is the region after the\n\t * third letter. But RV is the end of the word if these positions cannot be found.\n\t */\n\tif ( length > 3 ) {\n\t\tif ( ! isVowel( word[ 1 ], vowels ) ) {\n\t\t\trv = nextVowelPosition( word, vowels, 2 ) + 1;\n\t\t} else if ( isVowel( word[ 0 ], vowels ) && isVowel( word[ 1 ], vowels ) ) {\n\t\t\trv = nextConsonantPosition( word, vowels, 2 ) + 1;\n\t\t} else {\n\t\t\trv = 3;\n\t\t}\n\t}\n\n\tconst r1Text = word.slice( r1 );\n\tconst r2Text = word.slice( r2 );\n\tlet rvText = word.slice( rv );\n\n\t// Go through the first step of removing suffixes.\n\tconst wordAfterStep1 = stemStandardSuffixes( word, morphologyData.externalStemmer.standardSuffixes, r1Text, r2Text, rvText );\n\n\t// If no suffixes were removed in the first step, search for and remove verb suffixes.\n\tlet wordAfterStep2 = \"\";\n\n\tif ( word === wordAfterStep1 ) {\n\t\twordAfterStep2 = stemVerbSuffixes( word, morphologyData.externalStemmer.verbSuffixes, rvText );\n\t}\n\n\t// If suffixes were removed in one of the previous steps, replace the word with the de-suffixed word and adjust RV text.\n\tif ( word !== wordAfterStep1 ) {\n\t\tword = wordAfterStep1;\n\t\trvText = word.slice( rv );\n\t} else if ( word !== wordAfterStep2 ) {\n\t\tword = wordAfterStep2;\n\t\trvText = word.slice( rv );\n\t}\n\n\t/*\n\t * If a suffix was removed in one of the two previous steps, remove -i if preceded by -c and in RV. If no suffix was\n\t * removed in one of the previous steps, remove -os, -a, -i, -o, -á, í, or ó if in RV.\n\t */\n\tif ( wordAfterStep1 !== word || wordAfterStep2 !== word ) {\n\t\tif ( word.endsWith( morphologyData.externalStemmer.ciToC[ 0 ] ) && rvText.endsWith( morphologyData.externalStemmer.ciToC[ 1 ] ) ) {\n\t\t\tword = word.slice( 0, -1 );\n\t\t\trvText = word.slice( rv );\n\t\t}\n\t} else {\n\t\tconst foundGeneralSuffix = findMatchingEndingInArray( rvText, morphologyData.externalStemmer.generalSuffixes );\n\t\tif ( foundGeneralSuffix !== \"\" ) {\n\t\t\tword = word.slice( 0, -foundGeneralSuffix.length );\n\t\t\trvText = word.slice( rv );\n\t\t}\n\t}\n\n\t// Stem residual suffixes, regardless of whether a suffix was removed in any of the previous steps or not.\n\tword = stemResidualSuffixes( word, morphologyData.externalStemmer.residualSuffixes, rvText );\n\n\t// Change the nasal vowel replacements back into the nasal vowels.\n\tword = replaceCharacters( word, nasalVowelsReplacement, nasalVowels );\n\n\treturn word;\n}\n"]}