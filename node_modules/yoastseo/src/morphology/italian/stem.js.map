{"version":3,"sources":["../../../../src/morphology/italian/stem.js"],"names":["stem","isVowel","letter","morphologyData","externalStemmer","vowels","includes","getNextVowelPos","word","start","length","i","getNextConsonantPos","endsinArr","suffixes","endsWith","replaceAcute","acuteReplacements","preProcessing","acuteReplacement","replace","reg","repl","vowelMarking","RegExp","match","p1","p2","p3","toUpperCase","preProcess","toLowerCase","quReplacement","determineRs","r1","r2","rv","removePronounSuffixes","rvText","foundSuffix","pronounSuffixes","foundSuffixPre1","slice","preSuffixesGerund","foundSuffixPre2","preSuffixesInfinitive","infinitiveCompletion","removeStandardSuffixes","r2Text","r1Text","regions","suffixGroup","standardSuffixes","region","replacement","removeVerbSuffixes","verbSuffixes","normalizeDigraphs","digraphCh","digraphNormalization","digraphGh","canonicalizeStem","stemsThatBelongToOneWord","paradigm","verbsWithMultipleStems","irregularDiminutives","checkWordInFullFormExceptions","exceptions","irregularPluralNounsAndAdjectives","substring","originalWord","wordAfter0","wordAfter1","generalSuffixes","canonicalStem"],"mappings":"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","file":"stem.js","sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable max-statements */\n/*\nCopyright (c) 2012, Leonardo Fenu, Chris Umbel\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nimport { createSingleRuleFromMorphologyData, createRulesFromMorphologyData } from \"../morphoHelpers/createRulesFromMorphologyData\";\n\n/**\n * Determines whether a letter is a vowel.\n *\n * @param {string} letter           The letter that has to be checked.\n * @param {Object} morphologyData   The Italian morphology data file.\n *\n * @returns {boolean} True if the letter is a vowel.\n */\nfunction isVowel( letter, morphologyData ) {\n\treturn morphologyData.externalStemmer.vowels.includes( letter );\n}\n\n/**\n * Determines the next position in a word that is a vowel.\n *\n * @param {string}  word            The word to be checked.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {number}  start           The position of the word where you start checking.\n *\n * @returns {number} The next position in a word that is a vowel, or the final position if no vowel is found.\n */\nfunction getNextVowelPos( word, morphologyData, start ) {\n\tstart = start + 1;\n\tconst length = word.length;\n\n\tfor ( let i = start; i < length; i++ ) {\n\t\tif ( isVowel( word[ i ], morphologyData ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn length;\n}\n\n/**\n * Determines the next position in a word that is a consonant.\n *\n * @param {string}  word            The word that has to be checked.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {number}  start           The position of the word where you start checking.\n *\n * @returns {number} The next position in a word that is a consonant, or the final position if no consonant is found.\n */\nfunction getNextConsonantPos( word, morphologyData, start ) {\n\tconst length = word.length;\n\n\tfor ( let i = start; i < length; i++ ) {\n\t\tif ( ! isVowel( word[ i ], morphologyData ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn length;\n}\n\n/**\n * Checks whether a word ends in a suffix and if so it returns the suffix.\n *\n * @param {string}       word           The word that has to be checked.\n * @param {string[]}     suffixes       The suffixes that have to be checked.\n *\n * @returns {string}                    The suffix that the word ends in or an empty string if the word does not end in any of the suffixes.\n */\nfunction endsinArr( word, suffixes ) {\n\tfor ( let i = 0; i < suffixes.length; i++ ) {\n\t\tif ( word.endsWith( suffixes[ i ] ) ) {\n\t\t\treturn suffixes[ i ];\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\n/**\n * Turns acute accents into grave ones.\n *\n * @param {string}  word            The word that has to be checked.\n * @param {Object}  morphologyData  The Italian morphology data file.\n *\n * @returns {string} The word with acute accents (e.g. é) replaced by grave ones (e.g. è).\n */\nfunction replaceAcute( word, morphologyData ) {\n\tconst acuteReplacements = createRulesFromMorphologyData(\n\t\tmorphologyData.externalStemmer.preProcessing.acuteReplacements,\n\t\t\"gi\"\n\t);\n\n\tfor ( const acuteReplacement of acuteReplacements ) {\n\t\tword = word.replace( acuteReplacement.reg, acuteReplacement.repl );\n\t}\n\n\treturn word;\n}\n\n/**\n * Turns an i or u in between vowels into upper case.\n *\n * @param {string}  word            The word that has to be checked.\n * @param {Object}  morphologyData  The Italian morphology data file.\n *\n *  @returns {string} The word with either i or u turned into upper case.\n */\nfunction vowelMarking( word, morphologyData ) {\n\treturn word.replace(\n\t\tnew RegExp( morphologyData.externalStemmer.preProcessing.vowelMarking, \"g\" ),\n\t\t( match, p1, p2, p3 ) => p1 + p2.toUpperCase() + p3\n\t);\n}\n\n/**\n * Pre-process the word for stemming by setting it to lower case and replacing some letters.\n *\n * @param {string} word            The word to pre-process.\n * @param {Object} morphologyData  The Italian morphology data file.\n *\n * @returns {string} The pre-processed word.\n */\nfunction preProcess( word, morphologyData ) {\n\tword = word.toLowerCase();\n\tword = replaceAcute( word, morphologyData );\n\tconst quReplacement = createSingleRuleFromMorphologyData(\n\t\tmorphologyData.externalStemmer.preProcessing.quReplacement,\n\t\t\"g\"\n\t);\n\tword = word.replace( quReplacement.reg, quReplacement.repl );\n\tword = vowelMarking( word, morphologyData );\n\n\treturn word;\n}\n\n/**\n * Determines R1, R2 and RV in the word.\n *\n * @param {string}  word            The word for which Rs have to be determined.\n * @param {Object}  morphologyData  The Italian morphology data file.\n *\n * @returns {{r2: number, rv: number, r1: number}} R1, R2 and RV in the word.\n */\nconst determineRs = function( word, morphologyData ) {\n\tlet r1 = word.length;\n\tlet r2 = word.length;\n\tlet rv = word.length;\n\n\t// R1 is the region after the first non-vowel following a vowel,\n\tfor ( let i = 0; i < word.length - 1 && r1 === word.length; i++ ) {\n\t\tif ( isVowel( word[ i ], morphologyData ) && ! isVowel( word[ i + 1 ], morphologyData ) ) {\n\t\t\tr1 = i + 2;\n\t\t}\n\t}\n\n\t// R2 is the region after the first non-vowel following a vowel in R1\n\tfor ( let i = r1; i < word.length - 1 && r2 === word.length; i++ ) {\n\t\tif ( isVowel( word[ i ], morphologyData ) && ! isVowel( word[ i + 1 ], morphologyData ) ) {\n\t\t\tr2 = i + 2;\n\t\t}\n\t}\n\n\tif ( word.length > 3 ) {\n\t\tif ( ! isVowel( word[ 1 ], morphologyData ) ) {\n\t\t\t// If the second letter is a consonant, RV is the region after the next following vowel.\n\t\t\trv = getNextVowelPos( word, morphologyData, 1 ) + 1;\n\t\t} else if ( isVowel( word[ 0 ], morphologyData ) && isVowel( word[ 1 ], morphologyData ) ) {\n\t\t\t// Or if the first two letters are vowels, RV is the region after the next consonant.\n\t\t\trv = getNextConsonantPos( word, morphologyData, 2 ) + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Otherwise (consonant-vowel case) RV is the region after the third letter.\n\t\t\t * But RV is the end of the word if these positions cannot be found.\n\t\t\t */\n\t\t\trv = 3;\n\t\t}\n\t}\n\n\treturn { r1, r2, rv };\n};\n\n/**\n * Removes pronoun suffixes.\n *\n * @param {string}  word            The word from which suffixes have to be removed.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {string}  rvText          The content of the RV.\n *\n * @returns {string} The word without pronoun suffixes.\n */\nconst removePronounSuffixes = function( word, morphologyData, rvText ) {\n\tconst foundSuffix = endsinArr( word, morphologyData.externalStemmer.pronounSuffixes.suffixes, );\n\n\tif ( foundSuffix !== \"\" ) {\n\t\tconst foundSuffixPre1 = endsinArr(\n\t\t\trvText.slice( 0, -foundSuffix.length ),\n\t\t\tmorphologyData.externalStemmer.pronounSuffixes.preSuffixesGerund\n\t\t);\n\t\tconst foundSuffixPre2 = endsinArr(\n\t\t\trvText.slice( 0, -foundSuffix.length ),\n\t\t\tmorphologyData.externalStemmer.pronounSuffixes.preSuffixesInfinitive\n\t\t);\n\n\t\tif ( foundSuffixPre1 !== \"\" ) {\n\t\t\tword = word.slice( 0, -foundSuffix.length );\n\t\t}\n\t\tif ( foundSuffixPre2 !== \"\" ) {\n\t\t\tword = word.slice( 0, -foundSuffix.length ) + morphologyData.externalStemmer.pronounSuffixes.infinitiveCompletion;\n\t\t}\n\t}\n\treturn word;\n};\n\n/**\n * Removes standard suffixes.\n *\n * @param {string}  word            The word from which standard suffixes have to be removed.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {string}  r2Text          The content of the R2.\n * @param {string}  r1Text          The content of the R1.\n * @param {string}  rvText          The content of the RV.\n *\n * @returns {string} The word without standard suffixes.\n */\nconst removeStandardSuffixes = function( word, morphologyData, r2Text, r1Text, rvText ) {\n\tconst regions = {\n\t\tr1: r1Text,\n\t\tr2: r2Text,\n\t\trv: rvText,\n\t};\n\n\tfor ( const suffixGroup of morphologyData.externalStemmer.standardSuffixes ) {\n\t\tconst foundSuffix = endsinArr( regions[ suffixGroup.region ], suffixGroup.suffixes );\n\n\t\tif ( foundSuffix ) {\n\t\t\treturn word.slice( 0, -foundSuffix.length ) + suffixGroup.replacement;\n\t\t}\n\t}\n\n\treturn word;\n};\n\n/**\n *  Removes verb suffixes.\n *\n * @param {string}  word            The word from which verb suffixes have to be removed.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {string}  rvText          The content of the RV.\n *\n * @returns {string} The word without verb suffixes.\n */\nconst removeVerbSuffixes = function( word, morphologyData, rvText ) {\n\tconst foundSuffix  = endsinArr( rvText, morphologyData.externalStemmer.verbSuffixes );\n\n\tif ( foundSuffix ) {\n\t\tword = word.slice( 0, -foundSuffix.length );\n\t}\n\n\treturn word;\n};\n\n/**\n * Normalizes digraphs ch/gh to c/g.\n *\n * @param {string}  word    The word to normalize.\n * @param {Object}  morphologyData  The Italian morphology data file.\n * @param {string}  rvText          The content of the RV.\n *\n * @returns {string} The normalized word.\n */\nconst normalizeDigraphs = function( word, morphologyData, rvText ) {\n\tconst digraphCh = morphologyData.externalStemmer.digraphNormalization.digraphCh;\n\tconst digraphGh = morphologyData.externalStemmer.digraphNormalization.digraphGh;\n\n\tif ( ( rvText.endsWith( digraphCh[ 0 ] ) ) ) {\n\t\tword = word.slice( 0, -digraphGh[ 0 ].length ) + digraphCh[ 1 ];\n\t} else if ( ( rvText.endsWith( digraphGh[ 0 ] ) ) ) {\n\t\tword = word.slice( 0, -digraphGh[ 0 ].length ) + digraphGh[ 1 ];\n\t}\n\n\treturn word;\n};\n\n/**\n * Returns a canonical stem for words with multiple stems.\n *\n * @param {string}  word                       The word to canonicalize.\n * @param {Object}  stemsThatBelongToOneWord   An object of arrays of stems belonging to one word.\n *\n * @returns {string} A canonicalized stem or the original word.\n */\nconst canonicalizeStem = function( word, stemsThatBelongToOneWord ) {\n\t// Check the verbs list. The infinitive stem is always the canonical stem for verbs.\n\tfor ( const paradigm of stemsThatBelongToOneWord.verbsWithMultipleStems ) {\n\t\tif ( paradigm.includes( word ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\t// Check the diminutives list.\n\tfor ( const paradigm of stemsThatBelongToOneWord.irregularDiminutives ) {\n\t\tif ( paradigm.includes( word ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n};\n\n/**\n * Checks whether a word is in the full-form exception list and if so returns the canonical stem.\n *\n * @param {string} word\t      The word to be checked.\n * @param {Object} exceptions The list of full-form exceptions to be checked in.\n *\n * @returns {null|string} The canonical stem or null if nothing was found.\n */\nconst checkWordInFullFormExceptions = function( word, exceptions ) {\n\tfor ( const paradigm of exceptions ) {\n\t\tif ( paradigm[ 1 ].includes( word ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Stems Italian words.\n *\n * @param {string} word             The word to stem.\n * @param {Object} morphologyData   The Italian morphology data file.\n *\n * @returns {string}               The stemmed word.\n */\nexport default function stem( word, morphologyData ) {\n\t// Check the exception list for irregular plural nouns and adjectives.\n\tconst irregularPluralNounsAndAdjectives = checkWordInFullFormExceptions( word, morphologyData.irregularPluralNounsAndAdjectives );\n\tif ( irregularPluralNounsAndAdjectives ) {\n\t\treturn irregularPluralNounsAndAdjectives;\n\t}\n\t// Start word pre-processing.\n\tword = preProcess( word, morphologyData );\n\n\t// Don't stem words that consist of less than 3 letters.\n\tif ( word.length < 3 ) {\n\t\treturn word;\n\t}\n\n\t// Determines r1 ,r2, rv.\n\tconst { r1, r2, rv } = determineRs( word, morphologyData );\n\n\t// Determiners the content of r1, r2, and rv.\n\tlet r1Text = word.substring( r1 );\n\tlet r2Text = word.substring( r2 );\n\tlet rvText = word.substring( rv );\n\n\tconst originalWord = word;\n\n\t// Step 0: Attached pronoun removal.\n\tword = removePronounSuffixes( word, morphologyData, rvText );\n\n\tif ( word !== originalWord ) {\n\t\tr1Text = word.substring( r1 );\n\t\tr2Text = word.substring( r2 );\n\t\trvText = word.substring( rv );\n\t}\n\n\tconst wordAfter0 = word;\n\n\t// Step 1:  Standard suffix removal.\n\tword = removeStandardSuffixes( word, morphologyData, r2Text, r1Text, rvText );\n\n\tif ( word !== wordAfter0 ) {\n\t\trvText = word.substring( rv );\n\t}\n\n\tconst wordAfter1 = word;\n\n\t// Step 2:  Verb suffix removal.\n\tif ( wordAfter0 === wordAfter1 ) {\n\t\tword = removeVerbSuffixes( word, morphologyData, rvText );\n\t }\n\n\trvText = word.substring( rv );\n\n\t// Always do step 3.\n\tlet foundSuffix = \"\";\n\n\t// Remove general suffixes.\n\tif ( ( foundSuffix = endsinArr( rvText, morphologyData.externalStemmer.generalSuffixes ) ) !== \"\" ) {\n\t\tword = word.slice( 0, -foundSuffix.length );\n\t}\n\n\trvText = word.substring( rv );\n\n\t// Normalize digraphs ch/gh.\n\tword = normalizeDigraphs( word, morphologyData, rvText );\n\n\n\t// Returns a canonical stem for words with multiple stems (e.g., verbs: chiudere–chiuso; diminutives: ovetto-uovo).\n\tconst canonicalStem = canonicalizeStem( word, morphologyData.stemsThatBelongToOneWord );\n\tif ( canonicalStem ) {\n\t\treturn canonicalStem;\n\t}\n\treturn word.toLowerCase();\n}\n"]}