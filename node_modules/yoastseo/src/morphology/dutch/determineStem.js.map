{"version":3,"sources":["../../../../src/morphology/dutch/determineStem.js"],"names":["determineStem","checkStrongVerbExceptionList","strongVerbsLists","stemmedWord","key","Object","keys","stemsSet","stems","values","includes","findStemOnVerbExceptionList","morphologyDataNL","prefixes","pastParticipleStemmer","compoundVerbsPrefixes","foundPrefix","find","prefix","startsWith","doNotStemPrefix","stemExceptions","stemmingExceptionsWithMultipleStems","strongAndIrregularVerbs","doNotStemPrefixException","exception","endsWith","stemmedWordWithoutPrefix","slice","length","strongVerbExceptions","strongVerbStems","strongVerbsExceptionLists","irregularStrongVerbs","regularStrongVerbs","bothRegularAndIrregularStrongVerbs","i","checkIfWordIsException","word","stemFromExceptionList","stemmingExceptionsWithTwoStems","ambiguousEndings","ambiguousTAndDEndings","tAndDEndings","ending","stemmedWordWithoutTOrD"],"mappings":";;;;;QAsFgBA,a,GAAAA,a;;AAtFhB;;AACA;;AACA;;;;AACA;;AACA;;;;AAEA;;;;;;;;AAQA,MAAMC,+BAA+B,SAA/BA,4BAA+B,CAAUC,gBAAV,EAA4BC,WAA5B,EAA0C;AAC9E,MAAM,MAAMC,GAAZ,IAAmBC,OAAOC,IAAP,CAAaJ,gBAAb,CAAnB,EAAqD;AACpD,OAAM,MAAMK,QAAZ,IAAwBL,iBAAkBE,GAAlB,CAAxB,EAAkD;AACjD,SAAMI,QAAQ,uBAASH,OAAOI,MAAP,CAAeF,QAAf,CAAT,CAAd;AACA,OAAKC,MAAME,QAAN,CAAgBP,WAAhB,CAAL,EAAqC;AACpC,WAAOK,MAAO,CAAP,CAAP;AACA;AACD;AACD;AACD,CATD;;AAWA;;;;;;;;;;AAUA,MAAMG,8BAA8B,SAA9BA,2BAA8B,CAAUC,gBAAV,EAA4BT,WAA5B,EAA0C;AAC7E,OAAMU,WAAW,0CAAmBD,iBAAiBE,qBAAjB,CAAuCC,qBAA1D,CAAjB;AACA;AACA,KAAIC,cAAcH,SAASI,IAAT,CAAeC,UAAUf,YAAYgB,UAAZ,CAAwBD,MAAxB,CAAzB,CAAlB;AACA,OAAME,kBAAkBR,iBAAiBS,cAAjB,CAAgCC,mCAAhC,CAAoEC,uBAApE,CAA4FH,eAApH;AACA,OAAMI,2BAA2BJ,gBAAgBH,IAAhB,CAAsBQ,aAAatB,YAAYuB,QAAZ,CAAsBD,SAAtB,CAAnC,CAAjC;AACA,KAAIE,2BAA2B,EAA/B;;AAEA;AACA,KAAKH,wBAAL,EAAgC;AAC/B;AACAR,gBAAc,IAAd;AACA;AACA,EAJD,MAIO,IAAKA,WAAL,EAAmB;AACzB;AACAW,6BAA2BxB,YAAYyB,KAAZ,CAAmBZ,YAAYa,MAA/B,EAAuC1B,YAAY0B,MAAnD,CAA3B;AACA;AACA,MAAKF,yBAAyBE,MAAzB,GAAkC,CAAvC,EAA2C;AAC1C1B,iBAAcwB,wBAAd;AACA,GAFD,MAEO;AACN;AACAX,iBAAc,IAAd;AACA;AACD;;AAED,OAAMc,uBAAuBlB,iBAAiBS,cAAjB,CAAgCC,mCAAhC,CAAoEC,uBAApE,CAA4FQ,eAAzH;AACA;AACA,OAAMC,4BAA4B,CAAEF,qBAAqBG,oBAAvB,EAA6CH,qBAAqBI,kBAAlE,EACjCJ,qBAAqBK,kCADY,CAAlC;AAGA,MAAM,IAAIC,IAAI,CAAd,EAAiBA,IAAIJ,0BAA0BH,MAA/C,EAAuDO,GAAvD,EAA6D;AAC5D,QAAMC,yBAA0BpC,6BAA8B+B,0BAA2BI,CAA3B,CAA9B,EAA8DjC,WAA9D,CAAhC;AACA,MAAKkC,sBAAL,EAA8B;AAC7B;AACA,OAAKrB,WAAL,EAAmB;AAClB,WAAOA,cAAcf,6BAA8B+B,0BAA2BI,CAA3B,CAA9B,EAA8DjC,WAA9D,CAArB;AACA;AACD;AACA,UAAOF,6BAA8B+B,0BAA2BI,CAA3B,CAA9B,EAA8DjC,WAA9D,CAAP;AACA;AACD;AACD,CAzCD;;AA2CA;;;;;;;;AAQO,SAASH,aAAT,CAAwBsC,IAAxB,EAA8B1B,gBAA9B,EAAiD;AACvD,OAAMT,cAAc,oBAAMmC,IAAN,EAAY1B,gBAAZ,CAApB;;AAEA;AACA,KAAI2B,wBAAwB,0DAC3B3B,iBAAiBS,cAAjB,CAAgCC,mCAAhC,CAAoEkB,8BADzC,EACyErC,WADzE,CAA5B;AAEA,KAAKoC,qBAAL,EAA6B;AAC5B,SAAOA,qBAAP;AACA;AACDA,yBAAwB5B,4BAA6BC,gBAA7B,EAA+CT,WAA/C,CAAxB;AACA,KAAKoC,qBAAL,EAA6B;AAC5B,SAAOA,qBAAP;AACA;;AAED;AACA,OAAME,mBAAmB7B,iBAAiB8B,qBAAjB,CAAuCC,YAAhE;AACA,MAAM,MAAMC,MAAZ,IAAsBH,gBAAtB,EAAyC;AACxC,MAAKtC,YAAYuB,QAAZ,CAAsBkB,MAAtB,CAAL,EAAsC;AACrC,SAAMC,yBAAyB,kDAAuBjC,gBAAvB,EAAyCT,WAAzC,EAAsDmC,IAAtD,CAA/B;AACA,OAAKO,sBAAL,EAA8B;AAC7B,WAAOA,sBAAP;AACA;AACD;AACD;;AAED,QAAO1C,WAAP;AACA","file":"determineStem.js","sourcesContent":["import { flattenSortLength } from \"../morphoHelpers/flattenSortLength\";\nimport { flatten } from \"lodash-es\";\nimport stem from \"./stem\";\nimport { stemTOrDFromEndOfWord } from \"./stemTOrDFromEndOfWord\";\nimport { checkExceptionListWithTwoStems } from \"../morphoHelpers/exceptionListHelpers\";\n\n/**\n * Checks if the word checked is in the list of strong verbs exceptions. If it is, only return the first stem from the stem set.\n * E.g. stems: help, hielp, geholp -> the stem returned would be \"help\".\n *\n * @param {Object} strongVerbsLists\tThe exception lists of strong verbs.\n * @param {string} stemmedWord The word to check.\n * @returns {string} The unique stem.\n */\nconst checkStrongVerbExceptionList = function( strongVerbsLists, stemmedWord ) {\n\tfor ( const key of Object.keys( strongVerbsLists ) ) {\n\t\tfor ( const stemsSet of strongVerbsLists[ key ] ) {\n\t\t\tconst stems = flatten( Object.values( stemsSet ) );\n\t\t\tif ( stems.includes( stemmedWord ) ) {\n\t\t\t\treturn stems[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Checks if the word checked is in the list of strong verbs exceptions. Before checking, see if the word has a prefix and delete it if it does.\n * If the stem after prefix deletion is in the verb exception list, only return the first stem from the stem set and attach back the prefix.\n * E.g. words to check: verhielp, stem set: help, hielp, geholp -> the stem returned would be \"verhelp\".\n *\n * @param  {Object} morphologyDataNL \tThe Dutch morphology data file.\n * @param  {string} stemmedWord \t\tThe word to check.\n *\n * @returns {string} The unique stem.\n */\nconst findStemOnVerbExceptionList = function( morphologyDataNL, stemmedWord ) {\n\tconst prefixes = flattenSortLength( morphologyDataNL.pastParticipleStemmer.compoundVerbsPrefixes );\n\t// Check whether the inputted stem is started with one of the separable compound prefixes\n\tlet foundPrefix = prefixes.find( prefix => stemmedWord.startsWith( prefix ) );\n\tconst doNotStemPrefix = morphologyDataNL.stemExceptions.stemmingExceptionsWithMultipleStems.strongAndIrregularVerbs.doNotStemPrefix;\n\tconst doNotStemPrefixException = doNotStemPrefix.find( exception => stemmedWord.endsWith( exception ) );\n\tlet stemmedWordWithoutPrefix = \"\";\n\n\t// Check whether the stemmedWord is in the list of strong verbs starting with be-, ont- or ver- that do not need to be stemmed.\n\tif ( doNotStemPrefixException ) {\n\t\t// Reset foundPrefix so that it won't be attached when the stem is found in the verb exception list.\n\t\tfoundPrefix = null;\n\t\t// If the inputted stem is started with one of the separable compound prefixes, the prefix needs to be deleted for now.\n\t} else if ( foundPrefix ) {\n\t\t// Delete the prefix for now.\n\t\tstemmedWordWithoutPrefix = stemmedWord.slice( foundPrefix.length, stemmedWord.length );\n\t\t// At least 3 characters left after prefix deletion so that e.g. \"be\" is not found in the stem \"berg\".\n\t\tif ( stemmedWordWithoutPrefix.length > 2 ) {\n\t\t\tstemmedWord = stemmedWordWithoutPrefix;\n\t\t} else {\n\t\t\t// Reset foundPrefix so that it won't be attached when the stem is found in the verb exception list.\n\t\t\tfoundPrefix = null;\n\t\t}\n\t}\n\n\tconst strongVerbExceptions = morphologyDataNL.stemExceptions.stemmingExceptionsWithMultipleStems.strongAndIrregularVerbs.strongVerbStems;\n\t// Find stem strong verbs lists.\n\tconst strongVerbsExceptionLists = [ strongVerbExceptions.irregularStrongVerbs, strongVerbExceptions.regularStrongVerbs,\n\t\tstrongVerbExceptions.bothRegularAndIrregularStrongVerbs,\n\t];\n\tfor ( let i = 0; i < strongVerbsExceptionLists.length; i++ ) {\n\t\tconst checkIfWordIsException =  checkStrongVerbExceptionList( strongVerbsExceptionLists[ i ], stemmedWord );\n\t\tif ( checkIfWordIsException ) {\n\t\t\t// If the word checked had a prefix previously, attach it back.\n\t\t\tif ( foundPrefix ) {\n\t\t\t\treturn foundPrefix + checkStrongVerbExceptionList( strongVerbsExceptionLists[ i ], stemmedWord );\n\t\t\t}\n\t\t\t// If the word checked did not have a prefix previously, only return the first stem.\n\t\t\treturn checkStrongVerbExceptionList( strongVerbsExceptionLists[ i ], stemmedWord );\n\t\t}\n\t}\n};\n\n/**\n * Return the unique stem for a given Dutch input word.\n *\n * @param {string} word The word to be checked.\n * @param {Object} morphologyDataNL The Dutch data file.\n *\n * @returns {string} The unique stem.\n */\nexport function determineStem( word, morphologyDataNL ) {\n\tconst stemmedWord = stem( word, morphologyDataNL );\n\n\t// Check whether the stemmed word is on an exception list of words with multiple stems. If it is, return the canonical stem.\n\tlet stemFromExceptionList = checkExceptionListWithTwoStems(\n\t\tmorphologyDataNL.stemExceptions.stemmingExceptionsWithMultipleStems.stemmingExceptionsWithTwoStems, stemmedWord );\n\tif ( stemFromExceptionList ) {\n\t\treturn stemFromExceptionList;\n\t}\n\tstemFromExceptionList = findStemOnVerbExceptionList( morphologyDataNL, stemmedWord );\n\tif ( stemFromExceptionList ) {\n\t\treturn stemFromExceptionList;\n\t}\n\n\t// If the stemmed word ends in -t or -d, check whether it should be stemmed further, and return the stem with or without the -t/d.\n\tconst ambiguousEndings = morphologyDataNL.ambiguousTAndDEndings.tAndDEndings;\n\tfor ( const ending of ambiguousEndings ) {\n\t\tif ( stemmedWord.endsWith( ending ) ) {\n\t\t\tconst stemmedWordWithoutTOrD = stemTOrDFromEndOfWord( morphologyDataNL, stemmedWord, word );\n\t\t\tif ( stemmedWordWithoutTOrD ) {\n\t\t\t\treturn stemmedWordWithoutTOrD;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stemmedWord;\n}\n\n"]}