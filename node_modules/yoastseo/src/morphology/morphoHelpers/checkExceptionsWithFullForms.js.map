{"version":3,"sources":["../../../../src/morphology/morphoHelpers/checkExceptionsWithFullForms.js"],"names":["morphologyDataNL","word","exceptionListWithFullForms","stemExceptions","stemmingExceptionStemsWithFullForms","stem","checkVerbFullFormsList","verbs","pastParticipleStemmer","compoundVerbsPrefixes","checkEndingMatchFullFormsList","endingMatch","checkExactMatchFullFormsList","exactMatch","verbFullFormsList","compoundVerbPrefixes","prefixes","foundPrefix","find","prefix","startsWith","slice","length","i","stemAndForms","j","includes","endingMatchFullFormsList","endsWith","precedingLexicalMaterial","exactMatchFullFormsList"],"mappings":"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","file":"checkExceptionsWithFullForms.js","sourcesContent":["import { flatten } from \"lodash-es\";\nimport { flattenSortLength } from \"./flattenSortLength\";\n\n/**\n * Checks whether the word is on the verbs sub-list of the full forms list. Before checking the list, checks whether the word\n * begins with one of the compound verb prefixes, and the prefix is removed if one is found. If a match is found after checking\n * the full forms list, the canonical stem is returned, with the prefix attached back if there was one in the input word.\n * e.g. aanbevelen -> aanbeveel\n *\n * @param {string}\t\t\tword\t\t\t\t\t\t\tThe word to check.\n * @param {string[]}\t\tverbFullFormsList\t\t\t\tThe list of verb forms we search for match in.\n * @param {Object}\t\t\tcompoundVerbPrefixes\t\t\tThe list of separable and inseparable compound verb prefixes.\n *\n * @returns {string|null}\tThe canonical stem or null if no match found.\n */\nconst checkVerbFullFormsList = function( word, verbFullFormsList, compoundVerbPrefixes ) {\n\tconst prefixes = flattenSortLength( compoundVerbPrefixes );\n\n\t// Check whether the inputted word starts with one of the compound prefixes\n\tconst foundPrefix = prefixes.find( prefix => word.startsWith( prefix ) );\n\n\tif ( typeof( foundPrefix ) === \"string\" ) {\n\t\tword = word.slice( foundPrefix.length );\n\t}\n\n\tfor ( let i = 0; i < verbFullFormsList.length; i++ ) {\n\t\tconst stemAndForms = flatten( verbFullFormsList[ i ] );\n\t\tfor ( let j = 0; j < stemAndForms.length; j++ ) {\n\t\t\tif ( stemAndForms.includes( word ) ) {\n\t\t\t\tif ( typeof( foundPrefix ) === \"string\" ) {\n\t\t\t\t\treturn ( foundPrefix + stemAndForms[ 0 ] );\n\t\t\t\t}\n\t\t\t\treturn stemAndForms[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Checks whether the word is on the sub-list of the full forms list for which we search for an ending match between one of\n * the forms and the word (i.e., whether the word ends with a form from the list). If a match is found, the canonical\n * stem is returned. e.g. fitnesscentra -> fitnesscentrum\n *\n * @param {string}\t\t\tword\t\t\t\t\t\t\tThe word to check.\n * @param {string[]}\t\tendingMatchFullFormsList\t\tThe list we search for an ending match in.\n * @returns {string|null}\tThe canonical stem or null if no match found.\n */\nconst checkEndingMatchFullFormsList = function( word, endingMatchFullFormsList ) {\n\tfor ( let i = 0; i < endingMatchFullFormsList.length; i++ ) {\n\t\tconst stemAndForms = flatten( endingMatchFullFormsList[ i ] );\n\t\tfor ( let j = 0; j < stemAndForms.length; j++ ) {\n\t\t\tif ( word.endsWith( stemAndForms[ j ] ) ) {\n\t\t\t\t/*\n\t\t\t\t * Check if the word checked is actually a compound word. e.g. familielid\n\t\t\t\t * The character/s preceding the words in the exception should be at least 2 characters in order to be a valid compound element.\n\t\t\t\t*/\n\t\t\t\tconst precedingLexicalMaterial = word.slice( 0, -stemAndForms[ j ].length );\n\n\t\t\t\tif ( precedingLexicalMaterial.length === 1 ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ( precedingLexicalMaterial.length > 1 ) {\n\t\t\t\t\treturn ( precedingLexicalMaterial + stemAndForms[ 0 ] );\n\t\t\t\t}\n\t\t\t\treturn stemAndForms[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Checks whether the word is on the sub-list of the full forms list for which we search for the exact match between one of\n * the forms and the word. If a match is found, the canonical stem is returned. e.g. curricula -> curriculum\n *\n * @param {string}\t\t\tword\t\t\t\t\t\tThe word to check.\n * @param {string[]}\t\texactMatchFullFormsList\t\tThe list we search for an exact match in.\n * @returns {string|null}\tThe canonical stem or null if no match found.\n */\nconst checkExactMatchFullFormsList = function( word, exactMatchFullFormsList ) {\n\tfor ( let i = 0; i < exactMatchFullFormsList.length; i++ ) {\n\t\tconst stemAndForms = flatten( exactMatchFullFormsList[ i ] );\n\t\tfor ( let j = 0; j < stemAndForms.length; j++ ) {\n\t\t\tif ( stemAndForms.includes( word ) ) {\n\t\t\t\treturn stemAndForms[ 0 ];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n *\n * Checks whether a word is on the exception list for which we have full forms. If it is, returns the indicated stem of the word.\n *\n * @param {Array} morphologyDataNL The Dutch morphology data file.\n * @param {string} word The word to check.\n *\n * @returns {string/null} The created word forms.\n */\nexport default function( morphologyDataNL, word ) {\n\tconst exceptionListWithFullForms = morphologyDataNL.stemExceptions.stemmingExceptionStemsWithFullForms;\n\n\tlet stem = checkVerbFullFormsList( word, exceptionListWithFullForms.verbs, morphologyDataNL.pastParticipleStemmer.compoundVerbsPrefixes );\n\tif ( stem ) {\n\t\treturn stem;\n\t}\n\n\tstem = checkEndingMatchFullFormsList( word, exceptionListWithFullForms.endingMatch );\n\tif ( stem ) {\n\t\treturn stem;\n\t}\n\n\tstem = checkExactMatchFullFormsList( word, exceptionListWithFullForms.exactMatch );\n\tif ( stem ) {\n\t\treturn stem;\n\t}\n\n\treturn null;\n}\n"]}