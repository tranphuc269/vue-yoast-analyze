{"version":3,"sources":["../../../../src/morphology/spanish/stem.js"],"names":["stem","isVowel","c","regex","test","nextVowelPosition","word","start","length","position","nextConsonantPosition","removeAccent","accentedVowels","vowels","i","replace","endsIn","suffix","slice","checkWordInFullFormExceptions","exceptions","paradigm","includes","tryStemAsMente","r1Text","menteStemming","notMenteAdverbs","menteToStem","tryStemAsSuperlative","superlativesStemming","superlativeSuffix","superlativeSuffixes","notSuperlatives","superlativeToStem","tryStemAsDiminutive","diminutivesStemming","diminutiveSuffix","notDiminutives","wordWithoutEnding","endsWith","irregularDiminutives","diminutiveToStem","canonicalizeStem","stemmedWord","stemsThatBelongToOneWord","nouns","adjectives","verbs","stemVerbSuffixes","wordAfter1","rvText","rv","suf","suf11","suf12","morphologyData","toLowerCase","ifException","exceptionStemsWithFullForms","nonPluralsOnS","wordsThatLookLikeButAreNot","r1","r2","r2Text","originalWord","pronounSuffix","pronounSuffixPre1","pronounSuffixPre2","notVerbsEndingInPersonalPronouns","preSuffix","wordAfter0","suf1","suf2","suf3","suf4","suf5","suf9","suf10","ifMente","ifSuperlative","ifDiminutive","notVerbForms","wordWithoutS","suf13","canonicalStem"],"mappings":"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","file":"stem.js","sourcesContent":["/* eslint-disable max-statements, require-jsdoc, complexity */\n// The function will be further adjected anyways, so it makes no sense to randomly split it in smaller functions now.\n// The orginal stemmer is available at https://github.com/dmarman/lorca/blob/master/src/stemmer.js.\nimport { buildOneFormFromRegex } from \"../morphoHelpers/buildFormRule\";\nimport createRulesFromMorphologyData from \"../morphoHelpers/createRulesFromMorphologyData\";\nimport { findMatchingEndingInArray } from \"../morphoHelpers/findMatchingEndingInArray\";\n\n/**\n * Copyright (C) 2018 Domingo Martín Mancera\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n */\n\n\nconst isVowel = function( c ) {\n\tconst regex = /[aeiouáéíóú]/gi;\n\n\treturn regex.test( c );\n};\n\nconst nextVowelPosition = function( word, start = 0 ) {\n\tconst length = word.length;\n\n\tfor ( let position = start; position < length; position++ ) {\n\t\tif ( isVowel( word[ position ] ) ) {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\treturn length;\n};\n\nconst nextConsonantPosition = function( word, start = 0 ) {\n\tconst length = word.length;\n\n\tfor ( let position = start; position < length; position++ ) {\n\t\tif ( ! isVowel( word[ position ] ) ) {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\treturn length;\n};\n\nconst removeAccent = function( word ) {\n\tconst accentedVowels = [ \"á\", \"é\", \"í\", \"ó\", \"ú\" ];\n\tconst vowels = [ \"a\", \"e\", \"i\", \"o\", \"u\" ];\n\n\tfor ( let i = 0; i < accentedVowels.length; i++ ) {\n\t\tword = word.replace( accentedVowels[ i ], vowels[ i ] );\n\t}\n\n\treturn word;\n};\n\nconst endsIn = function( word, suffix ) {\n\tif ( word.length < suffix.length ) {\n\t\treturn false;\n\t}\n\n\treturn ( word.slice( -suffix.length ) === suffix );\n};\n\n/**\n * Checks whether a word is in the full-form exception list and if so returns the canonical stem.\n *\n * @param {string} word\t      The word to be checked.\n * @param {Object} exceptions The list of full-form exceptions to be checked in.\n *\n * @returns {null|string} The canonical stem or null if nothing was found.\n */\nconst checkWordInFullFormExceptions = function( word, exceptions ) {\n\tfor ( const paradigm of exceptions ) {\n\t\tif ( paradigm[ 1 ].includes( word ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * The function considers if the input word can be an adverb in -mente and if so stems it.\n * @param   {string}   word                                      The word to stem.\n * @param   {string}   r1Text                                    The R1 region of the word to stem.\n * @param   {Object}   menteStemming                      An object containing information about how to stem mente-adverbs.\n * @param   {string[]} menteStemming.notMente      An array of words that look like mente-adverbs but are not.\n * @param   {Array}    menteStemming.menteToStem    An array of pairs of regexes to match.\n * @returns {string}   A stemmed adverb or the input word, if it is not an adverb.\n */\nconst tryStemAsMente = function( word, r1Text, menteStemming ) {\n\tconst suffix = endsIn( r1Text, \"mente\" );\n\n\t// Immediately return the input word if no mente suffix is found or the word is in the stopList.\n\tif ( suffix === \"\" || menteStemming.notMenteAdverbs.includes( word ) ) {\n\t\treturn word;\n\t}\n\n\treturn buildOneFormFromRegex( word, createRulesFromMorphologyData( menteStemming.menteToStem ) ) || word;\n};\n\n/**\n * The function considers if the input word can be a superlative and if so stems it.\n * @param   {string}   word                                      The word to stem.\n * @param   {string}   r1Text                                    The R1 region of the word to stem.\n * @param   {Object}   superlativesStemming                      An object containing information about how to stem superlatives.\n * @param   {string[]} superlativesStemming.superlativeSuffixes  An array of suffixes possible in superlatives.\n * @param   {string[]} superlativesStemming.notSuperlatives      An array of words that look like superlatives but are not.\n * @param   {Array}    superlativesStemming.superlativeToStem    An array of pairs of regexes to match.\n * @returns {string}   A stemmed superlative or the input word, if it is not a superlative.\n */\nconst tryStemAsSuperlative = function( word, r1Text, superlativesStemming ) {\n\tconst superlativeSuffix = findMatchingEndingInArray( r1Text, superlativesStemming.superlativeSuffixes );\n\n\t// Immediately return the input word if no superlative suffix is found or the word is in the stopList.\n\tif ( superlativeSuffix === \"\" || superlativesStemming.notSuperlatives.includes( word ) ) {\n\t\treturn word;\n\t}\n\n\treturn buildOneFormFromRegex( word, createRulesFromMorphologyData( superlativesStemming.superlativeToStem ) ) || word;\n};\n\n/**\n * The function considers if the input word can be a diminutive and if so stems it.\n * @param   {string}   word                                         The word to stem.\n * @param   {Object}   diminutivesStemming                          An object containing information about how to stem diminutives.\n * @param   {string[]} diminutivesStemming.notDiminutives           An array of words that look like diminutives but are not.\n * @param   {Array}    diminutivesStemming.diminutiveToStem         An array of pairs of regexes to match.\n * @param   {Array}    diminutivesStemming.irregularDiminutives     An array containing data for irregular diminutives.\n *\n * @returns {string}   A stemmed diminutive or the input word, if it is not a diminutive.\n */\nconst tryStemAsDiminutive = function( word, diminutivesStemming ) {\n\tconst diminutiveSuffix = findMatchingEndingInArray( word, [ \"ito\", \"ita\", \"itos\", \"itas\", \"íto\", \"íta\", \"ítos\", \"ítas\" ] );\n\n\t// Immediately return the input word if no diminutive suffix is found or the word is in the stopList.\n\tif ( diminutiveSuffix === \"\" ||  diminutivesStemming.notDiminutives.includes( word ) ) {\n\t\treturn word;\n\t}\n\n\t// Remove o/a/os/as and check irregular diminutives ending in -it-/-ít-\n\tconst wordWithoutEnding = word.endsWith( \"s\" )\n\t\t? word.slice( 0, word.length - 2 )\n\t\t: word.slice( 0, word.length - 1 );\n\n\tfor ( const paradigm of diminutivesStemming.irregularDiminutives ) {\n\t\tif ( paradigm[ 1 ].includes( wordWithoutEnding ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\n\treturn buildOneFormFromRegex( word, createRulesFromMorphologyData(  diminutivesStemming.diminutiveToStem ) ) || word;\n};\n\n/**\n * Checks whether a stem is in an exception list of verbs, nouns or adjectives with multiple stems and if so returns\n * the canonical stem.\n *\n * @param {string} stemmedWord\t            The stemmed word to be checked.\n * @param {Object} stemsThatBelongToOneWord The POS-specific data that shows how non-canonical stems should be canonicalized.\n *\n * @returns {null|string} The canonical stem or null if nothing was found.\n */\nconst canonicalizeStem = function( stemmedWord, stemsThatBelongToOneWord ) {\n\t// First check for nouns with multiple stems, which are only diminutives.\n\tfor ( const paradigm of stemsThatBelongToOneWord.nouns ) {\n\t\tif ( paradigm.includes( stemmedWord ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\n\t// Second check for adjectives with multiple stems, which are only adjectives ending in -bl/-bil.\n\tfor ( const paradigm of stemsThatBelongToOneWord.adjectives ) {\n\t\tif ( paradigm.includes( stemmedWord ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\n\t// Last check for verbs that have irregular forms.\n\tfor ( const paradigm of stemsThatBelongToOneWord.verbs ) {\n\t\tif ( paradigm.includes( stemmedWord ) ) {\n\t\t\treturn paradigm[ 0 ];\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Stems verb suffixes.\n *\n * @param {string}  word                The original word.\n * @param {string}  wordAfter1          The word after step 1.\n * @param {string}  rvText              The text of the RV.\n * @param {number}  rv                  The start position of the RV.\n * @param {Object}  morphologyData      The Spanish morphology data.\n *\n * @returns {string} The word with the verb suffixes removed (if applicable).\n */\nconst stemVerbSuffixes = function( word, wordAfter1, rvText, rv ) {\n\t// Do step 2a if no ending was removed by step 1.\n\tconst suf = findMatchingEndingInArray( rvText, [ \"ya\", \"ye\", \"yan\", \"yen\", \"yeron\", \"yendo\", \"yo\", \"yó\", \"yas\", \"yes\", \"yais\", \"yamos\" ] );\n\n\tif ( suf !== \"\" && ( word.slice( -suf.length - 1, -suf.length ) === \"u\" ) ) {\n\t\tword = word.slice( 0, -suf.length );\n\t}\n\n\tif ( word !== wordAfter1 ) {\n\t\trvText = word.slice( rv );\n\t}\n\n\t// Do Step 2b if step 2a was done, but failed to remove a suffix.\n\tif ( word === wordAfter1 ) {\n\t\tconst suf11 = findMatchingEndingInArray( rvText, [ \"arían\", \"arías\", \"arán\", \"arás\", \"aríais\", \"aría\", \"aréis\",\n\t\t\t\"aríamos\", \"aremos\", \"ará\", \"aré\", \"erían\", \"erías\", \"erán\",\n\t\t\t\"erás\", \"eríais\", \"ería\", \"eréis\", \"eríamos\", \"eremos\", \"erá\",\n\t\t\t\"eré\", \"irían\", \"irías\", \"irán\", \"irás\", \"iríais\", \"iría\", \"iréis\",\n\t\t\t\"iríamos\", \"iremos\", \"irá\", \"iré\", \"aba\", \"ada\", \"ida\", \"ía\", \"ara\",\n\t\t\t\"iera\", \"ad\", \"ed\", \"id\", \"ase\", \"iese\", \"aste\", \"iste\", \"an\",\n\t\t\t\"aban\", \"ían\", \"aran\", \"ieran\", \"asen\", \"iesen\", \"aron\", \"ieron\",\n\t\t\t\"ado\", \"ido\", \"ando\", \"iendo\", \"ió\", \"ar\", \"er\", \"ir\", \"as\", \"abas\",\n\t\t\t\"adas\", \"idas\", \"ías\", \"aras\", \"ieras\", \"ases\", \"ieses\", \"ís\", \"áis\",\n\t\t\t\"abais\", \"íais\", \"arais\", \"ierais\", \"  aseis\", \"ieseis\", \"asteis\",\n\t\t\t\"isteis\", \"ados\", \"idos\", \"amos\", \"ábamos\", \"íamos\", \"imos\", \"áramos\",\n\t\t\t\"iéramos\", \"iésemos\", \"ásemos\" ] );\n\t\tconst suf12 = findMatchingEndingInArray( rvText, [ \"en\", \"es\", \"éis\", \"emos\" ] );\n\t\tif ( suf11 !== \"\" ) {\n\t\t\tword = word.slice( 0, -suf11.length );\n\t\t} else if ( suf12 !== \"\" ) {\n\t\t\tword = word.slice( 0, -suf12.length );\n\t\t\tif ( endsIn( word, \"gu\" ) ) {\n\t\t\t\tword = word.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn word;\n};\n\n/**\n * Stems Spanish words.\n *\n * @param {string} word            The word to stem.\n * @param {Object} morphologyData  The Spanish morphology data.\n *\n * @returns {string} The stemmed word.\n */\nexport default function stem( word, morphologyData ) {\n\tword.toLowerCase();\n\n\tconst ifException = checkWordInFullFormExceptions( word, morphologyData.exceptionStemsWithFullForms );\n\tif ( ifException ) {\n\t\treturn ifException;\n\t}\n\n\tconst nonPluralsOnS = morphologyData.wordsThatLookLikeButAreNot.nonPluralsOnS;\n\tif ( nonPluralsOnS.includes( word ) ) {\n\t\treturn removeAccent( word );\n\t}\n\n\tconst length = word.length;\n\tif ( length < 2 ) {\n\t\treturn removeAccent( word );\n\t}\n\n\tlet r1 = length;\n\tlet r2 = length;\n\tlet rv = length;\n\n\t/**\n\t * R1 is the region after the first non-vowel following a vowel, or is the null region at the end of the word if\n\t * there is no such non-vowel.\n\t */\n\tfor ( let i = 0; i < ( length - 1 ) && r1 === length; i++ ) {\n\t\tif ( isVowel( word[ i ] ) && ! isVowel( word[ i + 1 ] ) ) {\n\t\t\tr1 = i + 2;\n\t\t}\n\t}\n\n\t/**\n\t * R2 is the region after the first non-vowel following a vowel in R1, or is the null region at the end of the\n\t * word if there is no such non-vowel.\n\t */\n\tfor ( let i = r1; i < ( length - 1 ) && r2 === length; i++ ) {\n\t\tif ( isVowel( word[ i ] ) && ! isVowel( word[ i + 1 ] ) ) {\n\t\t\tr2 = i + 2;\n\t\t}\n\t}\n\n\tif ( length > 3 ) {\n\t\tif ( ! isVowel( word[ 1 ] ) ) {\n\t\t\trv = nextVowelPosition( word, 2 ) + 1;\n\t\t} else if ( isVowel( word[ 0 ] ) && isVowel( word[ 1 ] ) ) {\n\t\t\trv = nextConsonantPosition( word, 2 ) + 1;\n\t\t} else {\n\t\t\trv = 3;\n\t\t}\n\t}\n\n\tlet r1Text = word.slice( r1 );\n\tlet r2Text = word.slice( r2 );\n\tlet rvText = word.slice( rv );\n\tconst originalWord = word;\n\n\t// Step 0: Attached pronoun\n\tconst pronounSuffix = [ \"me\", \"se\", \"sela\", \"selo\", \"selas\", \"selos\", \"la\", \"le\", \"lo\", \"las\", \"les\", \"los\", \"nos\" ];\n\tconst pronounSuffixPre1 = [ \"iéndo\", \"ándo\", \"ár\", \"ér\", \"ír\" ];\n\tconst pronounSuffixPre2 = [ \"iendo\", \"ando\", \"ar\", \"er\", \"ir\" ];\n\n\tconst suffix = findMatchingEndingInArray( word, pronounSuffix );\n\n\tif ( suffix !== \"\" && ! morphologyData.wordsThatLookLikeButAreNot.notVerbsEndingInPersonalPronouns.includes( word ) ) {\n\t\tlet preSuffix = findMatchingEndingInArray( rvText.slice( 0, -suffix.length ), pronounSuffixPre1 );\n\n\t\tif ( preSuffix === \"\" ) {\n\t\t\tpreSuffix = findMatchingEndingInArray( rvText.slice( 0, -suffix.length ), pronounSuffixPre2 );\n\n\t\t\tif ( preSuffix !== \"\" || ( endsIn( word.slice( 0, -suffix.length ), \"uyendo\" ) ) ) {\n\t\t\t\tword = word.slice( 0, -suffix.length );\n\t\t\t}\n\t\t} else {\n\t\t\tword = removeAccent( word.slice( 0, -suffix.length ) );\n\t\t}\n\t}\n\n\tif ( word !== originalWord ) {\n\t\tr1Text = word.slice( r1 );\n\t\tr2Text = word.slice( r2 );\n\t\trvText = word.slice( rv );\n\t}\n\n\tconst wordAfter0 = word;\n\n\tconst suf1 = findMatchingEndingInArray( r2Text, [ \"anza\", \"anzas\", \"ico\", \"ica\", \"icos\", \"icas\", \"ismo\", \"ismos\",\n\t\t\"able\", \"ables\", \"ible\", \"ibles\", \"ista\", \"istas\", \"oso\", \"osa\",\n\t\t\"osos\", \"osas\", \"amiento\", \"amientos\", \"imiento\", \"imientos\" ] );\n\tconst suf2 = findMatchingEndingInArray( r2Text, [ \"icadora\", \"icador\", \"icación\", \"icadoras\", \"icadores\", \"icaciones\",\n\t\t\"icante\", \"icantes\", \"icancia\", \"icancias\", \"adora\", \"ador\", \"ación\",\n\t\t\"adoras\", \"adores\", \"aciones\", \"ante\", \"antes\", \"ancia\", \"ancias\" ] );\n\tconst suf3 = findMatchingEndingInArray( r2Text, [ \"logía\", \"logías\" ] );\n\tconst suf4 = findMatchingEndingInArray( r2Text, [ \"ución\", \"uciones\" ] );\n\tconst suf5 = findMatchingEndingInArray( r2Text, [ \"encia\", \"encias\" ] );\n\tconst suf9 = findMatchingEndingInArray( r2Text, [ \"abilidad\", \"abilidades\", \"icidad\", \"icidades\", \"ividad\", \"ividades\", \"idad\", \"idades\" ] );\n\tconst suf10 = findMatchingEndingInArray( r2Text, [ \"ativa\", \"ativo\", \"ativas\", \"ativos\", \"iva\", \"ivo\", \"ivas\", \"ivos\" ] );\n\n\tif ( suf1 !== \"\" ) {\n\t\tword = word.slice( 0, -suf1.length );\n\t} else if ( suf2 !== \"\" ) {\n\t\tword = word.slice( 0, -suf2.length );\n\t} else if ( suf3 !== \"\" ) {\n\t\tword = word.slice( 0, -suf3.length ) + \"log\";\n\t} else if ( suf4 !== \"\" ) {\n\t\tword = word.slice( 0, -suf4.length ) + \"u\";\n\t} else if ( suf5 !== \"\" ) {\n\t\tword = word.slice( 0, -suf5.length ) + \"ente\";\n\t} else if ( suf9 !== \"\" ) {\n\t\tword = word.slice( 0, -suf9.length );\n\t} else if ( suf10 !== \"\" ) {\n\t\tword = word.slice( 0, -suf10.length );\n\t}\n\n\t// Check if the word is an adverb in -mente. Stem it as a adverb if so, and immediately return the result.\n\tconst ifMente = tryStemAsMente( word, r1Text, morphologyData.menteStemming );\n\tif ( ifMente !== word ) {\n\t\treturn removeAccent( ifMente );\n\t}\n\n\t// Check if the word is a superlative. Stem it as a superlative if so, and immediately return the result.\n\tconst ifSuperlative = tryStemAsSuperlative( word, r1Text, morphologyData.superlativesStemming );\n\tif ( ifSuperlative !== word ) {\n\t\treturn removeAccent( ifSuperlative );\n\t}\n\n\t// Check if the word is a diminutive. Stem it as a diminutive if so, and immediately return the result.\n\tconst ifDiminutive = tryStemAsDiminutive( word, morphologyData.diminutivesStemming );\n\tif ( ifDiminutive !== word ) {\n\t\treturn removeAccent( ifDiminutive );\n\t}\n\n\tif ( word !== wordAfter0 ) {\n\t\trvText = word.slice( rv );\n\t}\n\n\tconst wordAfter1 = word;\n\n\n\t// Step 2a and 2b stem verb suffixes.\n\tconst notVerbForms = morphologyData.wordsThatLookLikeButAreNot.notVerbForms;\n\n\tif ( wordAfter0 === wordAfter1 ) {\n\t\t// If the word ends in -s, it is removed before checking the non-verbs list, as the list does not include plural forms.\n\t\tlet wordWithoutS = word;\n\t\tif ( word.endsWith( \"s\" ) ) {\n\t\t\twordWithoutS = word.slice( 0, -1 );\n\t\t}\n\n\t\tif ( notVerbForms.includes( wordWithoutS ) ) {\n\t\t\t/*\n\t\t\t * If the word without -s is matched on the non-verbs list, we can perform the next (non-verb) stemming steps\n\t\t\t * with the -s removed. This is because all possible non-verb suffixes ending in -s also have an equivalent\n\t\t\t * without the -s (e.g. -as/a; -es/e), so will be stemmed after stripping the -s.\n\t\t\t */\n\t\t\tword = wordWithoutS;\n\t\t} else {\n\t\t\tword = stemVerbSuffixes( word, wordAfter1, rvText, rv, morphologyData );\n\t\t}\n\t}\n\n\trvText = word.slice( rv );\n\n\tconst suf13 = findMatchingEndingInArray( rvText, [ \"os\", \"a\", \"o\", \"á\", \"í\", \"ó\" ] );\n\tif ( suf13 !== \"\" ) {\n\t\tword = word.slice( 0, -suf13.length );\n\t} else if ( ( findMatchingEndingInArray( rvText, [ \"e\", \"é\" ] ) ) !== \"\" ) {\n\t\tword = word.slice( 0, -1 );\n\t\trvText = word.slice( rv );\n\t\tif ( endsIn( rvText, \"u\" ) && endsIn( word, \"gu\" ) ) {\n\t\t\tword = word.slice( 0, -1 );\n\t\t}\n\t}\n\n\tconst canonicalStem = canonicalizeStem( word, morphologyData.stemsThatBelongToOneWord );\n\tif ( canonicalStem ) {\n\t\treturn canonicalStem;\n\t}\n\n\treturn removeAccent( word );\n}\n"]}