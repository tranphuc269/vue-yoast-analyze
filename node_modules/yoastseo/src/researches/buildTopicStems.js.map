{"version":3,"sources":["../../../src/researches/buildTopicStems.js"],"names":["TopicPhrase","stemOriginalPairs","exactMatch","prototype","getStems","map","stemOriginalPair","stem","StemOriginalPair","original","buildStems","keyphrase","language","morphologyData","doubleQuotes","length","substring","words","getStem","word","lowCaseWord","toLocaleLowerCase","collectKeyphraseAndSynonymsStems","synonyms","synonymsSplit","keyphraseStems","synonymsStems","synonym","primeMorphologyData","collectStems","collectStemsWithMorphologyData"],"mappings":"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","file":"buildTopicStems.js","sourcesContent":["import filterFunctionWordsFromArray from \"../helpers/filterFunctionWordsFromArray.js\";\nimport retrieveStemmer from \"../helpers/retrieveStemmer.js\";\nimport getWords from \"../stringProcessing/getWords.js\";\nimport parseSynonyms from \"../stringProcessing/parseSynonyms\";\nimport { normalizeSingle } from \"../stringProcessing/quotes\";\n\nimport { includes } from \"lodash-es\";\nimport { isUndefined } from \"lodash-es\";\nimport { escapeRegExp } from \"lodash-es\";\nimport { memoize } from \"lodash-es\";\n\n/**\n * A topic phrase (i.e., a keyphrase or synonym) with stem-original pairs for the words in the topic phrase.\n *\n * @param {StemOriginalPair[]} stemOriginalPairs   The stem-original pairs for the words in the topic phrase.\n * @param {boolean}            exactMatch          Whether the topic phrase is an exact match.\n *\n * @constructor\n */\nfunction TopicPhrase( stemOriginalPairs = [], exactMatch = false ) {\n\tthis.stemOriginalPairs = stemOriginalPairs;\n\tthis.exactMatch = exactMatch;\n}\n\n/**\n * Returns all stems in the topic phrase.\n *\n * @returns {string[]|[]} The stems in the topic phrase or empty array if the topic phrase is exact match.\n */\nTopicPhrase.prototype.getStems = function() {\n\t// An exact match keyphrase doesn't have stems.\n\tif ( this.exactMatch ) {\n\t\treturn [];\n\t}\n\n\treturn this.stemOriginalPairs.map( stemOriginalPair => stemOriginalPair.stem );\n};\n\n/**\n * A stem-original pair ƒor a word in a topic phrase.\n *\n * @param {string}  stem        The stem of the topic phrase word.\n * @param {string}  original    The original word form the topic phrase (unsanitized)\n *\n * @constructor\n */\nfunction StemOriginalPair( stem, original ) {\n\tthis.stem = stem;\n\tthis.original = original;\n}\n\n/**\n * Analyzes the focus keyword string or one synonym phrase.\n * Checks if morphology is requested or if the user wants to match exact string.\n * If morphology is required the module finds a stem for all words (if no function words list available) or\n * for all content words (i.e., excluding prepositions, articles, conjunctions, if the function words list is available).\n *\n * @param {string} keyphrase The keyphrase of the paper (or a synonym phrase) to get stem for.\n * @param {string} language The language to use for morphological analyzer and for function words.\n * @param {Object} morphologyData The available morphology data per language (false if unavailable).\n *\n * @returns {TopicPhrase} Object with an array of StemOriginalPairs of all (content) words in the keyphrase or synonym\n * phrase and information about whether the keyphrase/synonym should be matched exactly.\n */\nconst buildStems = function( keyphrase, language, morphologyData ) {\n\tif ( isUndefined( keyphrase ) || keyphrase === \"\" ) {\n\t\treturn new TopicPhrase();\n\t}\n\n\t// If the keyphrase is embedded in double quotation marks, return keyword itself, without outer-most quotation marks.\n\tconst doubleQuotes = [ \"“\", \"”\", \"〝\", \"〞\", \"〟\", \"‟\", \"„\", \"\\\"\" ];\n\tif ( includes( doubleQuotes, keyphrase[ 0 ] ) && includes( doubleQuotes, keyphrase[ keyphrase.length - 1 ] ) ) {\n\t\tkeyphrase = keyphrase.substring( 1, keyphrase.length - 1 );\n\t\treturn new TopicPhrase(\n\t\t\t[ new StemOriginalPair( escapeRegExp( keyphrase ), keyphrase ) ],\n\t\t\ttrue\n\t\t);\n\t}\n\n\tconst words = filterFunctionWordsFromArray( getWords( keyphrase ), language );\n\n\t/**\n\t * Extract a stemming function (if available, and if there is morphologyData available for this language).\n\t * Otherwise, take an identity function.\n\t */\n\tconst getStem = retrieveStemmer( language, morphologyData );\n\n\tconst stemOriginalPairs = words.map( word => {\n\t\tconst lowCaseWord = escapeRegExp( word.toLocaleLowerCase( language ) );\n\t\treturn new StemOriginalPair(\n\t\t\tgetStem( normalizeSingle( lowCaseWord ), morphologyData ),\n\t\t\tword,\n\t\t);\n\t} );\n\n\treturn new TopicPhrase( stemOriginalPairs );\n};\n\n/**\n * Builds stems of words of the keyphrase and of each synonym phrase.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getStem function (language specific).\n *\n * @returns {Object} Object with an array of stems of words in the keyphrase and an array of arrays of stems of words in the synonyms.\n */\nconst collectKeyphraseAndSynonymsStems = function( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst synonymsSplit = parseSynonyms( synonyms );\n\n\tconst keyphraseStems = buildStems( keyphrase, language, morphologyData );\n\tconst synonymsStems = synonymsSplit.map( synonym => buildStems( synonym, language, morphologyData ) );\n\n\treturn {\n\t\tkeyphraseStems,\n\t\tsynonymsStems,\n\t};\n};\n\n/**\n * Caches stems depending on the currently available morphologyData and (separately) keyphrase, synonyms,\n * and language. In this way, if the morphologyData remains the same in multiple calls of this function, the function\n * that collects actual stems only needs to check if the keyphrase, synonyms and language also remain the\n * same to return the cached result. The joining of keyphrase, synonyms and language for this function is needed,\n * because by default memoize caches by the first key only, which in the current case would mean that the function would\n * return the cached forms if the keyphrase has not changed (without checking if synonyms and language were changed).\n *\n * @param {Object|boolean} morphologyData The available morphology data.\n *\n * @returns {function} The function that collects the stems for a given set of keyphrase, synonyms, language and\n * morphologyData.\n */\nconst primeMorphologyData = memoize( ( morphologyData ) => {\n\treturn memoize( ( keyphrase, synonyms, language = \"en\" ) => {\n\t\treturn collectKeyphraseAndSynonymsStems( keyphrase, synonyms, language, morphologyData );\n\t}, ( keyphrase, synonyms, language ) => {\n\t\treturn keyphrase + \",\" + synonyms + \",\" + language;\n\t} );\n} );\n\n\n/**\n * Retrieves stems of words of the keyphrase and of each synonym phrase using the function that caches\n * the results of previous calls of this function.\n *\n * @param {string} keyphrase The paper's keyphrase.\n * @param {string} synonyms The paper's synonyms.\n * @param {string} language The paper's language.\n * @param {Object} morphologyData The available morphology data to be used by the getStems function (language specific).\n *\n * @returns {Object} Object with an array of stems of words in the keyphrase and an array of arrays of stems of words in the synonyms.\n */\nfunction collectStems( keyphrase, synonyms, language = \"en\", morphologyData ) {\n\tconst collectStemsWithMorphologyData = primeMorphologyData( morphologyData );\n\n\treturn collectStemsWithMorphologyData( keyphrase, synonyms, language );\n}\n\nexport {\n\tbuildStems,\n\tcollectStems,\n\tTopicPhrase,\n\tStemOriginalPair,\n};\n"]}