{"version":3,"sources":["../../../src/researches/getWordForms.js"],"names":["StemWithForms","stem","forms","Result","keyphraseForms","synonymsForms","getAllWordsFromPaper","paper","language","paperText","getText","altTagsInText","map","image","paperContent","getTitle","getUrl","getDescription","join","word","toLocaleLowerCase","replaceStemWithForms","stemOriginalPair","paperWordsGroupedByStems","matchingStemFormPair","find","element","originalSanitized","original","Object","keys","includes","createBasicWordForms","push","extractStems","keyphrase","synonyms","keyphraseStemsOnly","stemOriginalPairs","length","getStems","synonymsStemsOnly","topicPhrase","constructTopicPhraseResult","exactMatch","getWordForms","researcher","getLocale","morphologyData","getData","determineStem","topicPhrases","getKeyword","getSynonyms","keyphraseStems","synonymsStems","allTopicPhrases","every","synonym","topicStemsFlat","paperWords","paperWordsWithStems","StemOriginalPair","filter","sort","a","b","localeCompare","reduce","accumulator","lastItem"],"mappings":"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","file":"getWordForms.js","sourcesContent":["import { escapeRegExp, get, uniq } from \"lodash-es\";\nimport flattenDeep from \"lodash-es/flattenDeep\";\nimport filterFunctionWordsFromArray from \"../helpers/filterFunctionWordsFromArray\";\nimport getWordFormsFactory from \"../helpers/getBasicWordForms\";\nimport getLanguage from \"../helpers/getLanguage\";\nimport retrieveStemmer from \"../helpers/retrieveStemmer\";\n\nimport getAlttagContent from \"../stringProcessing/getAlttagContent\";\nimport getWords from \"../stringProcessing/getWords\";\nimport imageInText from \"../stringProcessing/imageInText\";\nimport parseSlug from \"../stringProcessing/parseSlug\";\nimport { normalizeSingle } from \"../stringProcessing/quotes\";\nimport { collectStems, StemOriginalPair } from \"./buildTopicStems\";\n\n/**\n * A stem with accompanying forms.\n *\n * @param {string}      stem    The word stem.\n * @param {string[]}    forms   The word forms for the stem.\n *\n * @constructor\n */\nfunction StemWithForms( stem, forms ) {\n\tthis.stem = stem;\n\tthis.forms = forms;\n}\n\n/**\n * A result for all topic forms.\n *\n * @param {string[]}    keyphraseForms  All keyphrase forms.\n * @param {Array<string[]>[]}    synonymsForms   All synonym forms.\n * @constructor\n */\nfunction Result( keyphraseForms = [], synonymsForms = [] ) {\n\tthis.keyphraseForms = keyphraseForms;\n\tthis.synonymsForms = synonymsForms;\n}\n\n/**\n * Gets all words found in the text, title, slug and meta description of a given paper.\n *\n * @param {Paper} paper     The paper for which to get the words.\n * @param {string} language The language of the paper.\n *\n * @returns {string[]} All words found.\n */\nfunction getAllWordsFromPaper( paper, language ) {\n\tconst paperText = paper.getText();\n\tconst altTagsInText = imageInText( paperText ).map( image => getAlttagContent( image ) );\n\n\tconst paperContent = [\n\t\tpaperText,\n\t\tpaper.getTitle(),\n\t\tparseSlug( paper.getUrl() ),\n\t\tpaper.getDescription(),\n\t\taltTagsInText.join( \" \" ),\n\t].join( \" \" );\n\n\treturn getWords( paperContent ).map(\n\t\tword => normalizeSingle( escapeRegExp( word.toLocaleLowerCase( language ) ) ) );\n}\n\n/**\n * Takes a stem-original pair and returns the accompanying forms for the stem that were found in the paper. Additionally\n * adds a sanitized version of the original word and (for specific languages) creates basic word forms.\n *\n * @param {StemOriginalPair}    stemOriginalPair            The stem-original pair for which to get forms.\n * @param {StemWithForms[]}     paperWordsGroupedByStems    All word forms in the paper grouped by stem.\n * @param {string}              language                    The language for which to get forms.\n *\n * @returns {string[]} All forms found in the paper for the given stem, plus a sanitized version of the original word.\n */\nfunction replaceStemWithForms( stemOriginalPair, paperWordsGroupedByStems, language ) {\n\tconst matchingStemFormPair = paperWordsGroupedByStems.find( element => element.stem === stemOriginalPair.stem );\n\tconst originalSanitized = normalizeSingle( escapeRegExp( stemOriginalPair.original.toLocaleLowerCase( language ) ) );\n\n\tconst forms = matchingStemFormPair\n\t\t? [ originalSanitized, ...matchingStemFormPair.forms ]\n\t\t: [ originalSanitized ];\n\n\t// Add extra forms for languages for which we have basic word form support.\n\tif ( Object.keys( getWordFormsFactory() ).includes( language ) ) {\n\t\tconst createBasicWordForms = getWordFormsFactory()[ language ];\n\t\tforms.push( ...createBasicWordForms( stemOriginalPair.original ) );\n\t}\n\n\t/*\n\t * Return original and found or created forms.\n\t * Only return original if no matching forms were found in the text and no forms could be created.\n\t */\n\treturn uniq( forms );\n}\n\n/**\n * Extracts the stems from all keyphrase and synonym stems.\n *\n * @param {TopicPhrase}   keyphrase  A topic phrase.\n * @param {TopicPhrase[]} synonyms   An array of topic phrases.\n *\n * @returns {string[]} All word stems of they keyphrase and synonyms.\n */\nfunction extractStems( keyphrase, synonyms ) {\n\tconst keyphraseStemsOnly = keyphrase.stemOriginalPairs.length === 0\n\t\t? []\n\t\t: keyphrase.getStems();\n\n\tconst synonymsStemsOnly = synonyms.length === 0\n\t\t? []\n\t\t: synonyms.map( topicPhrase => topicPhrase.getStems() );\n\n\treturn ( [ ...keyphraseStemsOnly, ...flattenDeep( synonymsStemsOnly ) ] );\n}\n\n/**\n * Constructs the result with forms for a topic phrase (i.e., a keyphrase or a synonym).\n *\n * @param {TopicPhrase}     topicPhrase                 The topic phrase for which to construct the result.\n * @param {StemWithForms[]} paperWordsGroupedByStems    All word forms in the paper grouped by stem.\n * @param {string}          language                    The language of the paper.\n *\n * @returns {Array.<string[]>} The word forms for a given topic phrase, grouped by original topic phrase word.\n */\nfunction constructTopicPhraseResult( topicPhrase, paperWordsGroupedByStems, language ) {\n\t// Empty result for an empty topic phrase.\n\tif ( topicPhrase.stemOriginalPairs.length === 0 ) {\n\t\treturn [];\n\t}\n\n\tif ( topicPhrase.exactMatch ) {\n\t\treturn [ [ topicPhrase.stemOriginalPairs[ 0 ].stem ] ];\n\t}\n\n\treturn topicPhrase.stemOriginalPairs.map( function( stemOriginalPair ) {\n\t\treturn replaceStemWithForms( stemOriginalPair, paperWordsGroupedByStems, language );\n\t} );\n}\n\n/**\n * Gets all matching word forms for the stems of the keyphrase and synonyms. Stems are either colleced from\n * the paper or, for specific languages, directly created.\n *\n * @param {Paper}       paper       The paper to build keyphrase and synonym forms for.\n * @param {Researcher}  researcher  The researcher.\n *\n * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms, based on the forms\n * found in the text or created forms.\n */\nfunction getWordForms( paper, researcher ) {\n\tconst language = getLanguage( paper.getLocale() );\n\tconst morphologyData = get( researcher.getData( \"morphology\" ), language, false );\n\tconst determineStem = retrieveStemmer( language, morphologyData );\n\tconst topicPhrases = collectStems( paper.getKeyword(), paper.getSynonyms(), language, morphologyData );\n\tconst keyphrase = topicPhrases.keyphraseStems;\n\tconst synonyms = topicPhrases.synonymsStems;\n\n\t// Return an empty result when no keyphrase and synonyms have been set.\n\tif ( keyphrase.stemOriginalPairs.length === 0 && synonyms.length === 0 ) {\n\t\treturn new Result();\n\t}\n\n\t// Return exact match if all topic phrases contain exact match. Forms don't need to be built in that case.\n\tconst allTopicPhrases = [ keyphrase, ...synonyms ];\n\n\tif ( allTopicPhrases.every( topicPhrase => topicPhrase.exactMatch === true ) ) {\n\t\treturn new Result(\n\t\t\t[ [ keyphrase.stemOriginalPairs[ 0 ].stem ] ],\n\t\t\tsynonyms.map( synonym => [ [ synonym.stemOriginalPairs[ 0 ].stem ] ]\n\t\t\t)\n\t\t);\n\t}\n\n\t// Get all stems from the keyphrase and synonyms.\n\tconst topicStemsFlat = uniq( extractStems( keyphrase, synonyms ) );\n\n\t// Get all words from the paper text, title, meta description and slug.\n\tlet paperWords = getAllWordsFromPaper( paper, language );\n\n\t// Filter doubles and function words.\n\tpaperWords = filterFunctionWordsFromArray( uniq( paperWords ), language );\n\n\t// Add stems to words from the paper, filter out all forms that aren't in the keyphrase or synonyms and order alphabetically.\n\tconst paperWordsWithStems = paperWords\n\t\t.map( word => new StemOriginalPair( determineStem( word, morphologyData ), word ) )\n\t\t.filter( stemOriginalPair => topicStemsFlat.includes( stemOriginalPair.stem ) )\n\t\t.sort( ( a, b ) => a.stem.localeCompare( b.stem ) );\n\n\t// Group word-stem pairs from the paper by stems.\n\tconst paperWordsGroupedByStems = paperWordsWithStems.reduce( function( accumulator, stemOriginalPair ) {\n\t\tconst lastItem = accumulator[ accumulator.length - 1 ];\n\n\t\tif ( accumulator.length === 0 || lastItem.stem !== stemOriginalPair.stem ) {\n\t\t\taccumulator.push( new StemWithForms( stemOriginalPair.stem, [ stemOriginalPair.original ] ) );\n\t\t} else {\n\t\t\tlastItem.forms.push( stemOriginalPair.original );\n\t\t}\n\n\t\treturn accumulator;\n\t}, [] );\n\n\treturn new Result(\n\t\tconstructTopicPhraseResult( keyphrase, paperWordsGroupedByStems, language ),\n\t\tsynonyms.map( synonym => constructTopicPhraseResult( synonym, paperWordsGroupedByStems, language ) )\n\t);\n}\n\nexport default getWordForms;\n"]}