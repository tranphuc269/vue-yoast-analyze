{"version":3,"sources":["../../../../../src/parsedPaper/assess/scoreAggregators/SEOScoreAggregator.js"],"names":["ScoreScale","ScoreFactor","SEOScoreAggregator","ScoreAggregator","aggregate","results","score","reduce","sum","result","getScore","Math","round","length"],"mappings":";;;;;;AAAA;;;;;;AAEA;;;;;;;;;;;AAWA,MAAMA,aAAa,GAAnB;;AAEA;;;;;;;;;;;AAWA,MAAMC,cAAc,CAApB;;AAEA;;;;;AAKA,MAAMC,kBAAN,SAAiCC,yBAAjC,CAAiD;AAChD;;;;;;;AAOAC,YAAWC,OAAX,EAAqB;AACpB,UAAMC,QAAQD,QAAQE,MAAR,CAAgB,CAAEC,GAAF,EAAOC,MAAP,KAAmBD,MAAMC,OAAOC,QAAP,EAAzC,EAA4D,CAA5D,CAAd;;AAEA;;;;;AAKA,WAAOC,KAAKC,KAAL,CAAcN,QAAQN,UAAV,IAA2BK,QAAQQ,MAAR,GAAiBZ,WAA5C,CAAZ,KAA2E,CAAlF;AACA;AAjB+C;;kBAoBlCC,kB","file":"SEOScoreAggregator.js","sourcesContent":["import ScoreAggregator from \"./ScoreAggregator\";\n\n/**\n * The number to scale the score to.\n *\n * Individual scores are from 1 to 9.\n * The total score should be multiplied by this number to scale up.\n *\n * @type {number}\n * @const\n *\n * @memberOf module:parsedPaper/assess\n */\nconst ScoreScale = 100;\n\n/**\n * The factor to multiply the amount of results with.\n *\n * Individual scores are from 1 to 9.\n * The make the total score work in the 100 scale, the amount of results needs to get multiplied by this factor.\n *\n * @type {number}\n * @const\n *\n * @memberOf module:parsedPaper/assess\n */\nconst ScoreFactor = 9;\n\n/**\n * Aggregates SEO assessment results into a single score.\n *\n * @memberOf module:parsedPaper/assess\n */\nclass SEOScoreAggregator extends ScoreAggregator {\n\t/**\n\t * Aggregates the given assessment results into a single score.\n\t *\n\t * @param {AssessmentResult[]} results The assessment results.\n\t *\n\t * @returns {number} The aggregated score.\n\t */\n\taggregate( results ) {\n\t\tconst score = results.reduce( ( sum, result ) => sum + result.getScore(), 0 );\n\n\t\t/*\n\t\t * Whenever the divide by part is 0 this can result in a `NaN` value. Then 0 should be returned as fallback.\n\t\t * This seemed better than the if check `results.length === 0`,\n\t\t * because it also protects against ScoreFactor being 0.\n\t\t */\n\t\treturn Math.round( ( score * ScoreScale ) / ( results.length * ScoreFactor ) ) || 0;\n\t}\n}\n\nexport default SEOScoreAggregator;\n"]}